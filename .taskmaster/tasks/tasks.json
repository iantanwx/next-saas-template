{
  "master": {
    "tasks": [
      {
        "id": 2,
        "title": "Implement Local-First Architecture",
        "description": "Design and implement a local-first architecture that allows the application to work offline with seamless synchronization using Rocicorp Zero as the sync engine.",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "details": "1. Set up Rocicorp Zero client with local storage\n2. Create data access layer that prioritizes local data\n3. Implement optimistic UI updates with Zero's mutation system\n4. Design sync conflict detection using Zero's conflict resolution\n5. Create data models compatible with Zero's schema system\n6. Implement background sync process using Zero's sync engine\n7. Add network status detection\n8. Create fallback mechanisms for when server is unreachable",
        "testStrategy": "1. Test application functionality while offline\n2. Verify data synchronizes correctly when connection is restored using Zero\n3. Simulate network interruptions to ensure resilience\n4. Validate that local changes are preserved during sync\n5. Measure performance impact of local-first approach with Zero\n6. Test Zero's conflict resolution mechanisms",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up local SQLite database with Electric SQL",
            "description": "Initialize and configure a local SQLite database using Electric SQL to enable offline data storage and synchronization capabilities.",
            "status": "done",
            "dependencies": [],
            "details": "Install Electric SQL dependencies and configure the client. Set up the SQLite database schema with appropriate tables for the application data. Define the necessary migrations for the database structure. Configure Electric SQL with the appropriate connection settings for both local development and production environments. Initialize the database connection in the application startup process.\n<info added on 2025-08-05T08:40:05.149Z>\nUpdated to use PGlite instead of SQLite for better PostgreSQL compatibility. PGlite is a lightweight PostgreSQL implementation that runs in the browser and provides full PostgreSQL features while maintaining compatibility with Electric SQL. The setup should initialize PGlite in a dedicated web worker to avoid blocking the main thread and improve performance. This includes configuring the web worker communication layer, setting up the PGlite instance with appropriate memory limits, and establishing the Electric SQL client connection through the worker interface. The database schema should leverage PostgreSQL-specific features that PGlite supports, such as JSON columns and advanced indexing capabilities.\n</info added on 2025-08-05T08:40:05.149Z>\n<info added on 2025-08-09T02:12:36.413Z>\nSince we're now migrating to Rocicorp Zero instead of Electric SQL/PGlite, this subtask needs to be completely reoriented. The new focus should be on setting up Zero's local storage system which uses a fundamentally different architecture. Zero provides its own local storage layer that doesn't require manual SQLite or PGlite configuration. Instead, we need to install the @rocicorp/zero package, initialize the Zero client with appropriate server configuration, define data schemas using Zero's schema definition system, set up the local cache storage that Zero manages automatically, and configure the initial sync settings. Zero handles the local storage internally using IndexedDB in browsers, so we don't need to manage database files directly. The setup involves creating Zero mutators for data operations, defining the initial data model schemas, configuring the Zero server connection settings, and initializing the Zero client in the application bootstrap process.\n</info added on 2025-08-09T02:12:36.413Z>",
            "testStrategy": "Verify database connection and initialization. Test basic CRUD operations against the local database. Ensure database schema matches the expected structure."
          },
          {
            "id": 2,
            "title": "Migrate from Electric SQL to Rocicorp Zero",
            "description": "Replace the existing PGlite/Electric SQL setup with Rocicorp Zero for local-first synchronization.",
            "status": "pending",
            "dependencies": [],
            "details": "Install Rocicorp Zero client dependencies. Configure Zero client with appropriate server connection settings. Migrate existing data models to Zero's schema format. Set up Zero's local storage system to replace PGlite. Initialize Zero client in the application with proper authentication and sync configuration. Remove Electric SQL and PGlite dependencies and related worker setup. Update existing data access patterns to use Zero's API instead of direct SQL queries.",
            "testStrategy": "Verify Zero client initializes correctly. Test data model compatibility with Zero's schema system. Ensure local storage functionality works as expected. Validate that existing functionality is preserved after migration."
          },
          {
            "id": 3,
            "title": "Configure tRPC split link architecture",
            "description": "Implement a tRPC split link configuration that supports both WebSocket connections for subscriptions and HTTP connections for queries and mutations.",
            "status": "pending",
            "dependencies": [],
            "details": "Create a tRPC WebSocket link that connects to the CloudFlare Worker for real-time subscriptions. Implement an HTTP link for queries and mutations that connects to Next.js API routes. Configure a split link that routes subscription operations to the WebSocket link and other operations to the HTTP link. Add error handling and reconnection logic for both links. Implement request batching for the HTTP link to optimize performance.",
            "testStrategy": "Test both subscription and query/mutation operations to ensure they're routed correctly. Verify reconnection behavior when connections are interrupted. Measure performance impact of request batching."
          },
          {
            "id": 4,
            "title": "Implement data access layer with Zero's local-first priority",
            "description": "Create a data access layer that uses Zero's built-in local-first capabilities for data operations.",
            "status": "pending",
            "dependencies": [],
            "details": "Develop a data access abstraction that leverages Zero's local-first architecture. Implement methods for CRUD operations using Zero's query and mutation APIs. Utilize Zero's automatic synchronization mechanisms for server updates. Create query hooks that work with Zero's reactive data system. Implement Zero's subscription system for real-time updates. Add caching strategies that complement Zero's built-in local storage.",
            "testStrategy": "Test data access methods with Zero's local-first behavior. Verify that Zero's automatic sync works correctly. Test Zero's reactive queries and subscriptions. Ensure compatibility with existing application patterns."
          },
          {
            "id": 5,
            "title": "Design and implement Zero-based subscriptions",
            "description": "Utilize Zero's built-in subscription system for real-time data updates.",
            "status": "pending",
            "dependencies": [
              4
            ],
            "details": "Configure Zero's subscription system for real-time data updates. Implement subscription queries using Zero's query API. Create client-side subscription management that integrates with Zero's reactive system. Utilize Zero's built-in data normalization and caching. Implement subscription filtering and optimization using Zero's query capabilities. Ensure subscriptions work seamlessly with Zero's offline-first approach.",
            "testStrategy": "Test Zero's subscription system activation and data updates. Verify real-time updates are correctly processed. Test subscription behavior in offline/online transitions. Validate performance with Zero's built-in optimizations."
          },
          {
            "id": 6,
            "title": "Implement optimistic UI updates using Zero's mutation system",
            "description": "Leverage Zero's built-in optimistic updates and mutation system for immediate UI feedback.",
            "status": "pending",
            "dependencies": [
              4
            ],
            "details": "Implement optimistic updates using Zero's mutation system that provides automatic rollback capabilities. Utilize Zero's built-in offline queue for mutations when disconnected. Configure Zero's conflict resolution strategies for concurrent modifications. Implement custom mutation logic where needed using Zero's mutation API. Leverage Zero's automatic retry mechanisms for failed operations. Add custom error handling for mutations that complement Zero's built-in error handling.",
            "testStrategy": "Test Zero's optimistic updates for immediate UI feedback. Verify Zero's automatic rollback behavior for failed mutations. Test offline mutation queueing and processing. Validate Zero's conflict resolution in concurrent scenarios."
          },
          {
            "id": 7,
            "title": "Implement network status detection with Zero integration",
            "description": "Add network status detection that works seamlessly with Zero's sync engine and connection management.",
            "status": "pending",
            "dependencies": [
              4,
              6
            ],
            "details": "Implement network status detection that integrates with Zero's connection state. Utilize Zero's built-in sync status indicators for user feedback. Create a network status store that combines browser APIs with Zero's connection information. Implement user notifications that leverage Zero's sync state changes. Add retry strategies that complement Zero's built-in retry mechanisms. Ensure network status UI reflects Zero's actual sync state.",
            "testStrategy": "Test network status detection with Zero's connection management. Verify sync status indicators reflect Zero's actual state. Test user notifications during connection changes. Validate that retry mechanisms work with Zero's built-in retry logic."
          },
          {
            "id": 8,
            "title": "Configure Zero's conflict resolution system",
            "description": "Set up and customize Zero's built-in conflict detection and resolution mechanisms.",
            "status": "pending",
            "dependencies": [
              4,
              6,
              7
            ],
            "details": "Configure Zero's conflict resolution strategies based on application requirements. Implement custom conflict resolution handlers where Zero's built-in strategies are insufficient. Set up conflict logging and monitoring using Zero's conflict detection system. Create user interfaces for manual conflict resolution when needed. Implement conflict resolution rules that work with Zero's operational transform system. Add analytics for conflict patterns using Zero's conflict metadata.",
            "testStrategy": "Test Zero's conflict detection with concurrent modifications. Verify custom conflict resolution handlers work correctly. Test manual conflict resolution UI integration. Ensure conflict resolution maintains data consistency with Zero's system."
          }
        ]
      },
      {
        "id": 3,
        "title": "Implement GitHub OAuth Authentication",
        "description": "Add GitHub OAuth as an authentication option alongside the existing Google OAuth.",
        "details": "1. Register a new OAuth application in GitHub Developer settings\n2. Install required packages: `npm install @supabase/auth-helpers-nextjs`\n3. Configure Supabase authentication settings for GitHub provider\n4. Create GitHub OAuth callback route in Next.js\n5. Add GitHub login button to authentication UI\n6. Implement user profile data retrieval from GitHub\n7. Handle GitHub authentication errors\n8. Update user model to store GitHub-specific information",
        "testStrategy": "1. Test GitHub login flow end-to-end\n2. Verify user profile data is correctly retrieved and stored\n3. Test error handling for failed authentication\n4. Ensure existing Google OAuth still works properly\n5. Validate session management with GitHub authentication",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Email/Password Authentication",
        "description": "Add traditional email and password authentication to complement OAuth options.",
        "details": "1. Configure Supabase for email/password authentication\n2. Create registration form with email validation\n3. Implement password strength requirements\n4. Add login form for email/password authentication\n5. Create server-side validation for registration data\n6. Implement email verification process\n7. Add security headers for authentication routes\n8. Update authentication UI to include email/password option",
        "testStrategy": "1. Test registration process with valid and invalid inputs\n2. Verify email verification flow works correctly\n3. Test login with correct and incorrect credentials\n4. Ensure password strength requirements are enforced\n5. Validate that user data is correctly stored in database",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Password Reset Functionality",
        "description": "Create a secure password reset flow for users with email/password authentication.",
        "details": "1. Create password reset request form\n2. Implement password reset token generation in Supabase\n3. Design and implement password reset email template using Resend\n4. Create password reset confirmation page\n5. Add server-side validation for reset requests\n6. Implement token expiration and security checks\n7. Add rate limiting for password reset requests\n8. Create success/error notifications for the reset process",
        "testStrategy": "1. Test password reset flow end-to-end\n2. Verify token expiration works correctly\n3. Test with valid and invalid email addresses\n4. Ensure reset emails are sent and formatted correctly\n5. Validate security of the reset process against common attacks",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Magic Link Authentication",
        "description": "Add passwordless authentication using magic links sent via email.",
        "details": "1. Configure Supabase for magic link authentication\n2. Create magic link request form\n3. Implement magic link token generation\n4. Design and implement magic link email template using Resend\n5. Create magic link callback handler\n6. Add rate limiting for magic link requests\n7. Implement security checks for magic link authentication\n8. Update authentication UI to include magic link option",
        "testStrategy": "1. Test magic link authentication flow end-to-end\n2. Verify emails are sent correctly with valid links\n3. Test security of the magic link process\n4. Ensure rate limiting prevents abuse\n5. Validate user session is created correctly after magic link authentication",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Integrate Stripe for Payment Processing",
        "description": "Implement Stripe integration for handling subscription payments and billing.",
        "details": "1. Install Stripe packages: `npm install stripe @stripe/stripe-js`\n2. Set up Stripe account and API keys\n3. Create Stripe customer creation on user registration\n4. Implement Stripe Checkout for subscription creation\n5. Design subscription plan structure in Stripe dashboard\n6. Create database models for subscription data\n7. Implement client-side Stripe Elements for payment forms\n8. Add Stripe-related environment variables",
        "testStrategy": "1. Test subscription creation in test mode\n2. Verify customer creation in Stripe\n3. Test payment processing with test cards\n4. Ensure subscription data is correctly stored in database\n5. Validate error handling for failed payments",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Stripe Webhook Handling",
        "description": "Set up webhook endpoints to handle Stripe events for subscription updates, payments, and other billing events.",
        "details": "1. Create webhook endpoint in Next.js API routes\n2. Implement signature verification for Stripe webhooks\n3. Handle key events: payment_succeeded, payment_failed, subscription_updated, etc.\n4. Update local database based on webhook events\n5. Implement idempotency for webhook processing\n6. Add logging for webhook events\n7. Create error handling for webhook processing failures\n8. Test webhook handling with Stripe CLI",
        "testStrategy": "1. Use Stripe CLI to test webhook delivery\n2. Verify database updates based on webhook events\n3. Test idempotency by sending duplicate events\n4. Ensure security of webhook endpoint\n5. Validate error handling for malformed webhook data",
        "priority": "high",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Create Customer Portal for Subscription Management",
        "description": "Implement a customer portal that allows users to manage their subscriptions, payment methods, and billing information.",
        "details": "1. Set up Stripe Customer Portal configuration\n2. Create portal session generation endpoint\n3. Implement UI for accessing the customer portal\n4. Add return URL handling from the portal\n5. Create subscription status display in user dashboard\n6. Implement access control based on subscription status\n7. Add webhook handling for portal-initiated changes\n8. Create notifications for subscription changes",
        "testStrategy": "1. Test portal access and return flow\n2. Verify subscription changes are reflected in the application\n3. Test access control based on subscription status\n4. Ensure proper handling of portal-initiated changes\n5. Validate user experience for subscription management",
        "priority": "high",
        "dependencies": [
          7,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Subscription Management System",
        "description": "Create a comprehensive subscription management system that handles plan changes, cancellations, and subscription status.",
        "details": "1. Design subscription data model\n2. Implement subscription creation flow\n3. Create plan change functionality\n4. Implement cancellation handling\n5. Add subscription status checks\n6. Create subscription renewal logic\n7. Implement prorated billing for plan changes\n8. Add subscription metadata for feature access control",
        "testStrategy": "1. Test full subscription lifecycle\n2. Verify plan changes are handled correctly\n3. Test cancellation and reactivation flows\n4. Ensure billing is accurate for all subscription changes\n5. Validate feature access based on subscription status",
        "priority": "high",
        "dependencies": [
          7,
          8,
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Integrate Inngest for Workflow Management",
        "description": "Set up Inngest as the workflow engine for handling long-running processes and background jobs.",
        "details": "1. Install Inngest packages: `npm install inngest @inngest/nextjs`\n2. Configure Inngest client and connection\n3. Set up Inngest dev server for local development\n4. Create basic workflow function structure\n5. Implement event sending mechanism\n6. Add Inngest API key to environment variables\n7. Create Inngest dashboard access\n8. Set up deployment configuration for Inngest functions",
        "testStrategy": "1. Verify Inngest connection and configuration\n2. Test basic event sending and receiving\n3. Ensure local development setup works correctly\n4. Validate deployment configuration\n5. Test Inngest dashboard access and monitoring",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement Long-Running Job Infrastructure",
        "description": "Create infrastructure for long-running jobs that can operate for hours or days without failure.",
        "details": "1. Design job persistence model\n2. Implement job step functions in Inngest\n3. Create checkpoint mechanism for long-running jobs\n4. Implement job resumption after interruption\n5. Add timeout handling and retry logic\n6. Create job cancellation functionality\n7. Implement resource management for concurrent jobs\n8. Add monitoring for job health",
        "testStrategy": "1. Test job persistence through server restarts\n2. Verify checkpoint and resumption functionality\n3. Test timeout and retry mechanisms\n4. Ensure jobs can be properly cancelled\n5. Validate resource usage during concurrent job execution",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Create Workflow Progress Tracking System",
        "description": "Implement a system to track and report progress of long-running workflows to users.",
        "details": "1. Design progress tracking data model\n2. Implement progress update events in workflows\n3. Create real-time progress update mechanism\n4. Implement progress calculation for multi-step workflows\n5. Add estimated time remaining functionality\n6. Create progress visualization components\n7. Implement progress notification system\n8. Add progress history for completed workflows",
        "testStrategy": "1. Test progress updates during workflow execution\n2. Verify real-time updates reach the UI\n3. Test progress calculation accuracy\n4. Ensure progress history is correctly maintained\n5. Validate user experience of progress tracking",
        "priority": "high",
        "dependencies": [
          11,
          12
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Implement Workflow State Persistence",
        "description": "Create a system for persisting workflow state to enable resumption after interruptions or failures.",
        "details": "1. Design workflow state storage model\n2. Implement state serialization and deserialization\n3. Create state checkpoint mechanism\n4. Implement state restoration on workflow resumption\n5. Add versioning for state schema changes\n6. Create state cleanup for completed workflows\n7. Implement state compression for large datasets\n8. Add state encryption for sensitive data",
        "testStrategy": "1. Test state persistence through server restarts\n2. Verify state restoration works correctly\n3. Test handling of state schema changes\n4. Ensure state cleanup prevents data leaks\n5. Validate performance with large state objects",
        "priority": "high",
        "dependencies": [
          11,
          12
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Develop UI Component Library",
        "description": "Create a comprehensive UI component library for consistent design across the application.",
        "details": "1. Set up Tailwind CSS configuration\n2. Create base component structure\n3. Implement form components (inputs, selectors, buttons)\n4. Create data display components (tables, cards, lists)\n5. Implement feedback components (alerts, toasts, modals)\n6. Create layout components (containers, grids, sidebars)\n7. Implement navigation components (menus, tabs, breadcrumbs)\n8. Add accessibility features to all components",
        "testStrategy": "1. Test component rendering in various contexts\n2. Verify responsive behavior on different screen sizes\n3. Test accessibility compliance\n4. Ensure consistent styling across components\n5. Validate component composition patterns",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Implement Dashboard Templates",
        "description": "Create reusable dashboard templates for common SaaS application layouts and views.",
        "details": "1. Design main dashboard layout\n2. Create analytics dashboard template\n3. Implement settings page template\n4. Create user management dashboard\n5. Implement workflow monitoring dashboard\n6. Add subscription management template\n7. Create documentation page template\n8. Implement responsive behavior for all templates",
        "testStrategy": "1. Test template rendering with various data sets\n2. Verify responsive behavior on different devices\n3. Test navigation between dashboard sections\n4. Ensure consistent styling across templates\n5. Validate accessibility of dashboard templates",
        "priority": "high",
        "dependencies": [
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Implement Mobile Responsive Design",
        "description": "Ensure the entire application is fully responsive and works well on mobile devices.",
        "details": "1. Implement responsive breakpoints in Tailwind configuration\n2. Create mobile navigation component\n3. Adapt form layouts for small screens\n4. Implement touch-friendly interactions\n5. Create responsive table alternatives for mobile\n6. Optimize modal and dialog behavior on mobile\n7. Test and fix layout issues on various screen sizes\n8. Implement responsive typography",
        "testStrategy": "1. Test on various device sizes and orientations\n2. Verify usability on touch devices\n3. Test performance on mobile devices\n4. Ensure all features are accessible on small screens\n5. Validate that no horizontal scrolling occurs on mobile",
        "priority": "high",
        "dependencies": [
          15,
          16
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Implement Dark Mode Support",
        "description": "Add dark mode support throughout the application with user preference persistence.",
        "details": "1. Configure Tailwind for dark mode\n2. Create theme toggle component\n3. Implement system preference detection\n4. Add user preference persistence\n5. Update all components for dark mode compatibility\n6. Create dark mode variants for all icons and images\n7. Implement smooth transition between modes\n8. Add dark mode preview in user settings",
        "testStrategy": "1. Test theme switching functionality\n2. Verify system preference detection\n3. Test preference persistence across sessions\n4. Ensure all components render correctly in dark mode\n5. Validate contrast and accessibility in dark mode",
        "priority": "medium",
        "dependencies": [
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Create Workflow Status UI",
        "description": "Develop UI components for displaying workflow status, progress, and controls.",
        "details": "1. Design workflow status card component\n2. Implement progress visualization\n3. Create workflow control buttons (pause, resume, cancel)\n4. Add real-time status updates\n5. Implement error state display\n6. Create workflow history view\n7. Add detailed step information display\n8. Implement workflow logs viewer",
        "testStrategy": "1. Test status display with various workflow states\n2. Verify real-time updates are reflected in UI\n3. Test control buttons functionality\n4. Ensure error states are clearly communicated\n5. Validate usability of workflow history and logs",
        "priority": "medium",
        "dependencies": [
          13,
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Implement Real-time Updates UI",
        "description": "Create UI components and patterns for displaying real-time data updates throughout the application.",
        "details": "1. Design real-time update indicators\n2. Implement optimistic UI updates\n3. Create data refresh mechanisms\n4. Add conflict resolution UI\n5. Implement offline indicator\n6. Create sync status display\n7. Add real-time collaboration indicators\n8. Implement notification system for updates",
        "testStrategy": "1. Test real-time update flow with multiple clients\n2. Verify optimistic updates work correctly\n3. Test conflict resolution UI\n4. Ensure offline status is clearly indicated\n5. Validate user experience during synchronization",
        "priority": "medium",
        "dependencies": [
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "Implement Landing Pages",
        "description": "Create marketing-focused landing pages for the SaaS application.",
        "details": "1. Design main landing page layout\n2. Create feature showcase sections\n3. Implement pricing page\n4. Add testimonials section\n5. Create FAQ page\n6. Implement contact form\n7. Add call-to-action components\n8. Ensure SEO optimization for all landing pages",
        "testStrategy": "1. Test responsive behavior of landing pages\n2. Verify all links and forms work correctly\n3. Test performance and loading speed\n4. Ensure accessibility compliance\n5. Validate SEO elements are properly implemented",
        "priority": "medium",
        "dependencies": [
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Implement Loading States and Skeletons",
        "description": "Create consistent loading states and skeleton screens throughout the application.",
        "details": "1. Design skeleton components for common UI elements\n2. Implement loading state management\n3. Create loading indicators for actions\n4. Add skeleton screens for page transitions\n5. Implement progressive loading for large data sets\n6. Create shimmer effects for skeletons\n7. Add timeout handling for long-running operations\n8. Implement error states for failed loading",
        "testStrategy": "1. Test loading states with various network conditions\n2. Verify skeleton screens render correctly\n3. Test transition between loading and loaded states\n4. Ensure loading states are accessible\n5. Validate user experience during loading",
        "priority": "medium",
        "dependencies": [
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "Create Error Pages and Error Handling",
        "description": "Implement comprehensive error handling and custom error pages throughout the application.",
        "details": "1. Design 404 not found page\n2. Create 500 server error page\n3. Implement 403 forbidden page\n4. Add error boundary components\n5. Create toast notification system for errors\n6. Implement form validation error display\n7. Add retry mechanisms for failed operations\n8. Create error logging to Sentry",
        "testStrategy": "1. Test error pages with various error conditions\n2. Verify error boundaries catch component errors\n3. Test form validation error display\n4. Ensure error notifications are clear and helpful\n5. Validate error logging to Sentry works correctly",
        "priority": "medium",
        "dependencies": [
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "Implement Email Templates",
        "description": "Create a system for email templates and notifications using Resend.",
        "details": "1. Set up Resend integration\n2. Create base email template with branding\n3. Implement welcome email template\n4. Create password reset email template\n5. Implement verification email template\n6. Add subscription notification emails\n7. Create workflow status notification emails\n8. Implement team invitation email template",
        "testStrategy": "1. Test email delivery through Resend\n2. Verify email rendering in various email clients\n3. Test personalization in email templates\n4. Ensure all links in emails work correctly\n5. Validate email template responsiveness",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "Implement Progress Indicators",
        "description": "Create consistent progress indicators for various operations throughout the application.",
        "details": "1. Design linear progress component\n2. Implement circular progress indicator\n3. Create progress bar with percentage\n4. Add step indicator for multi-step processes\n5. Implement progress toast notifications\n6. Create progress modal for long-running operations\n7. Add progress indicators for file uploads\n8. Implement progress tracking for form completion",
        "testStrategy": "1. Test progress indicators with various durations\n2. Verify progress updates are smooth and accurate\n3. Test accessibility of progress indicators\n4. Ensure progress indicators are consistent across the application\n5. Validate user experience with progress feedback",
        "priority": "medium",
        "dependencies": [
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 26,
        "title": "Implement Background Jobs System",
        "description": "Create a system for managing and executing background jobs for data processing and maintenance tasks.",
        "details": "1. Design background job queue\n2. Implement job scheduler\n3. Create job worker infrastructure\n4. Add job status tracking\n5. Implement job retry mechanism\n6. Create job priority system\n7. Add job cancellation functionality\n8. Implement job result storage",
        "testStrategy": "1. Test job scheduling and execution\n2. Verify job status tracking works correctly\n3. Test retry mechanism for failed jobs\n4. Ensure job priorities are respected\n5. Validate job cancellation functionality",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "Implement File Upload System",
        "description": "Create a comprehensive file upload system with progress tracking and storage management.",
        "details": "1. Set up Supabase Storage configuration\n2. Create file upload component\n3. Implement drag-and-drop functionality\n4. Add upload progress tracking\n5. Create file type validation\n6. Implement file size limits\n7. Add direct-to-storage upload\n8. Create file management UI",
        "testStrategy": "1. Test file uploads of various types and sizes\n2. Verify progress tracking during upload\n3. Test validation of file types and sizes\n4. Ensure uploaded files are accessible\n5. Validate file management functionality",
        "priority": "medium",
        "dependencies": [
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Implement WebSocket Support",
        "description": "Add WebSocket support for real-time communication between clients and server.",
        "details": "1. Set up WebSocket server\n2. Create WebSocket connection management\n3. Implement message serialization/deserialization\n4. Add authentication for WebSocket connections\n5. Create channel subscription mechanism\n6. Implement presence tracking\n7. Add reconnection handling\n8. Create WebSocket event hooks",
        "testStrategy": "1. Test WebSocket connection establishment\n2. Verify message delivery in both directions\n3. Test authentication and security\n4. Ensure reconnection works after disconnection\n5. Validate performance with multiple concurrent connections",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up WebSocket Server in CloudFlare Worker",
            "description": "Implement a WebSocket server within a CloudFlare Worker that can accept and manage WebSocket connections from clients.",
            "dependencies": [],
            "details": "Create a new CloudFlare Worker that listens for WebSocket upgrade requests. Implement the necessary event handlers for connection, message, error, and close events. Set up the appropriate routes and handlers in the worker to distinguish WebSocket connections from regular HTTP requests. Configure CORS settings to allow connections from authorized origins. Implement basic logging and monitoring for WebSocket connections.",
            "status": "pending",
            "testStrategy": "Test WebSocket connection establishment from various clients. Verify the worker correctly handles upgrade requests. Test connection limits and ensure proper error handling for failed connections."
          },
          {
            "id": 2,
            "title": "Implement WebSocket Connection Management",
            "description": "Create a system to track active WebSocket connections, handle authentication, and manage connection lifecycle.",
            "dependencies": [
              "28.1"
            ],
            "details": "Develop a connection manager that maintains a registry of active WebSocket connections with unique identifiers. Implement authentication middleware that validates connection requests using JWT or similar tokens. Create mechanisms to handle connection timeouts, heartbeats, and graceful disconnections. Implement rate limiting to prevent abuse. Store connection metadata including client information, authentication status, and connection timestamp.",
            "status": "pending",
            "testStrategy": "Test authentication flow for WebSocket connections. Verify connections are properly tracked and can be retrieved by ID. Test connection timeout and heartbeat mechanisms. Validate rate limiting functionality."
          },
          {
            "id": 3,
            "title": "Develop WebSocket to Long HTTP Poll Proxy",
            "description": "Create the proxy mechanism that converts WebSocket messages to long HTTP poll requests for clients that cannot maintain WebSocket connections.",
            "dependencies": [
              "28.1",
              "28.2"
            ],
            "details": "Implement a proxy layer in the CloudFlare Worker that translates between WebSocket protocol and long HTTP polling. Create a message queue for each client to store messages when long polling connection is not active. Implement the HTTP endpoints for long polling clients to connect and receive queued messages. Develop a session management system to maintain state between polling requests. Ensure message ordering and delivery guarantees match WebSocket expectations.",
            "status": "pending",
            "testStrategy": "Test message delivery between WebSocket clients and long polling clients. Verify message ordering is preserved. Test reconnection scenarios and message queuing. Measure latency differences between direct WebSocket and proxied connections."
          },
          {
            "id": 4,
            "title": "Implement Message Serialization and Channel Subscription",
            "description": "Create a message format for communication and implement a channel-based subscription system for routing messages.",
            "dependencies": [
              "28.2",
              "28.3"
            ],
            "details": "Design and implement a standardized message format with headers for routing and metadata. Create serialization/deserialization functions for converting between JSON and binary formats as needed. Implement a channel subscription system allowing clients to subscribe to specific topics or channels. Develop message routing logic to deliver messages only to subscribed clients. Create APIs for clients to manage their channel subscriptions.",
            "status": "pending",
            "testStrategy": "Test message serialization with various data types and sizes. Verify channel subscription and unsubscription functionality. Test message routing to ensure messages are delivered only to appropriate subscribers. Validate performance with high message volumes."
          },
          {
            "id": 5,
            "title": "Implement Reconnection Handling and Presence Tracking",
            "description": "Add robust reconnection capabilities and implement presence tracking to monitor which clients are online.",
            "dependencies": [
              "28.2",
              "28.3",
              "28.4"
            ],
            "details": "Implement client-side reconnection logic with exponential backoff. Create server-side session resumption to maintain state across reconnections. Develop a presence system that tracks online status of users across different connection methods. Implement presence events that notify when users come online or go offline. Create a recovery mechanism to replay missed messages after reconnection. Add configurable timeouts for considering connections as stale.",
            "status": "pending",
            "testStrategy": "Test reconnection under various network failure scenarios. Verify session state is properly maintained after reconnection. Test presence updates are correctly broadcast to interested clients. Validate missed message recovery works correctly after reconnection."
          }
        ]
      },
      {
        "id": 29,
        "title": "Implement Role-Based Access Control",
        "description": "Create a comprehensive role-based access control system for organizations and resources.",
        "details": "1. Design role and permission data model\n2. Implement role assignment functionality\n3. Create permission checking middleware\n4. Add UI for role management\n5. Implement role-based UI adaptation\n6. Create permission inheritance system\n7. Add audit logging for permission changes\n8. Implement custom role creation",
        "testStrategy": "1. Test permission enforcement for various roles\n2. Verify role assignment functionality\n3. Test UI adaptation based on permissions\n4. Ensure audit logging captures all changes\n5. Validate security of the permission system",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "Implement Teams within Organizations",
        "description": "Add support for teams as a sub-grouping within organizations for more granular access control.",
        "details": "1. Design team data model\n2. Implement team creation and management\n3. Create team membership functionality\n4. Add team-based permission system\n5. Implement team settings UI\n6. Create team invitation system\n7. Add team activity feed\n8. Implement team resource sharing",
        "testStrategy": "1. Test team creation and management\n2. Verify team membership functionality\n3. Test team-based permissions\n4. Ensure team invitations work correctly\n5. Validate team resource sharing",
        "priority": "medium",
        "dependencies": [
          29
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 31,
        "title": "Implement Offline Support",
        "description": "Enhance the application to fully support offline usage with data synchronization when connection is restored.",
        "details": "1. Implement service worker for offline assets\n2. Create offline data access layer\n3. Implement offline action queueing\n4. Add conflict resolution strategies\n5. Create offline indicator UI\n6. Implement background sync when online\n7. Add offline mode toggle for testing\n8. Create offline usage analytics",
        "testStrategy": "1. Test application functionality while offline\n2. Verify data synchronization when connection is restored\n3. Test conflict resolution with concurrent changes\n4. Ensure offline indicator correctly shows connection status\n5. Validate offline action queue processing",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "Implement Conflict Resolution",
        "description": "Create a system for detecting and resolving data conflicts during synchronization.",
        "details": "1. Design conflict detection mechanism\n2. Implement last-write-wins strategy\n3. Create manual conflict resolution UI\n4. Add conflict metadata tracking\n5. Implement merge strategies for different data types\n6. Create conflict history\n7. Add notification system for conflicts\n8. Implement conflict resolution hooks",
        "testStrategy": "1. Test conflict detection with concurrent edits\n2. Verify automatic resolution strategies\n3. Test manual conflict resolution UI\n4. Ensure conflict metadata is correctly tracked\n5. Validate merge strategies for different data types",
        "priority": "medium",
        "dependencies": [
          31
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 33,
        "title": "Implement Real-time Collaboration",
        "description": "Create features for real-time collaboration between users working on the same data.",
        "details": "1. Implement presence indicators\n2. Create collaborative editing infrastructure\n3. Add cursor/selection sharing\n4. Implement operational transformation or CRDT\n5. Create user activity feed\n6. Add real-time chat functionality\n7. Implement collaboration permissions\n8. Create collaboration session management",
        "testStrategy": "1. Test real-time updates with multiple users\n2. Verify presence indicators show correct information\n3. Test collaborative editing functionality\n4. Ensure permissions are enforced in collaboration\n5. Validate performance with multiple collaborators",
        "priority": "medium",
        "dependencies": [
          28,
          31,
          32
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement WebSocket Infrastructure with tRPC Split Link",
            "description": "Set up the WebSocket infrastructure using tRPC split link to enable real-time communication between clients and server.",
            "dependencies": [],
            "details": "1. Install required dependencies (ws, @trpc/server, @trpc/client)\n2. Configure tRPC server to support WebSocket connections\n3. Implement a split link in the client to handle both HTTP and WebSocket connections\n4. Create a connection manager to handle WebSocket lifecycle events\n5. Implement reconnection logic with exponential backoff\n6. Add authentication middleware for WebSocket connections\n7. Create subscription handler utilities on the server side",
            "status": "pending",
            "testStrategy": "1. Test WebSocket connection establishment\n2. Verify reconnection works when connection drops\n3. Test authentication flow for WebSocket connections\n4. Measure connection performance under load"
          },
          {
            "id": 2,
            "title": "Implement Shape-Based Subscriptions for Different Data Types",
            "description": "Create subscription patterns for different data types (users, posts, etc.) to allow clients to subscribe to specific data changes.",
            "dependencies": [
              "33.1"
            ],
            "details": "1. Define subscription schemas for each data type (users, posts, documents, etc.)\n2. Implement subscription resolver functions on the server\n3. Create subscription endpoints in the tRPC router\n4. Implement filtering logic to send only relevant updates\n5. Add subscription management utilities on the client side\n6. Create hooks for easy subscription usage in React components\n7. Implement subscription cleanup on component unmount",
            "status": "pending",
            "testStrategy": "1. Test subscribing to different data types\n2. Verify only relevant updates are received\n3. Test subscription with multiple clients\n4. Ensure proper cleanup when subscriptions are no longer needed"
          },
          {
            "id": 3,
            "title": "Implement Real-time Presence System",
            "description": "Create a system to track and display user presence information, including online status and current activity.",
            "dependencies": [
              "33.1",
              "33.2"
            ],
            "details": "1. Create a presence data model to store user status information\n2. Implement heartbeat mechanism to track active users\n3. Create presence subscription endpoint\n4. Implement presence indicators in the UI (online, away, offline)\n5. Add user activity tracking (typing, viewing, editing)\n6. Create presence update throttling to prevent excessive updates\n7. Implement presence history for recently active users",
            "status": "pending",
            "testStrategy": "1. Test presence indicators with multiple users\n2. Verify presence updates in real-time\n3. Test timeout mechanism for inactive users\n4. Ensure presence history shows accurate information"
          },
          {
            "id": 4,
            "title": "Implement Collaborative Cursor and Selection Tracking",
            "description": "Create a system to track and display cursor positions and text selections of collaborators in real-time.",
            "dependencies": [
              "33.1",
              "33.3"
            ],
            "details": "1. Create data models for cursor position and selection ranges\n2. Implement cursor position tracking in text editors and other interactive elements\n3. Create throttled update mechanism to prevent excessive cursor updates\n4. Implement visual indicators for collaborator cursors with user identification\n5. Add selection highlighting with user-specific colors\n6. Create collision avoidance for multiple cursor indicators\n7. Implement cursor history playback for reviewing collaboration sessions",
            "status": "pending",
            "testStrategy": "1. Test cursor tracking with multiple users\n2. Verify cursor positions update in real-time\n3. Test selection highlighting with overlapping selections\n4. Ensure performance with many concurrent cursors"
          },
          {
            "id": 5,
            "title": "Implement Operational Transformation for Collaborative Editing",
            "description": "Create a collaborative editing system using Operational Transformation to handle concurrent edits without conflicts.",
            "dependencies": [
              "33.1",
              "33.4"
            ],
            "details": "1. Implement basic OT data types (Insert, Delete, Retain)\n2. Create transformation functions for operation pairs\n3. Implement a version vector to track document state\n4. Create server-side operation processing and broadcasting\n5. Implement client-side operation generation and application\n6. Add conflict resolution strategies for concurrent edits\n7. Create history tracking for undo/redo functionality\n8. Implement operation compression for efficiency",
            "status": "pending",
            "testStrategy": "1. Test concurrent editing scenarios\n2. Verify document consistency after concurrent edits\n3. Test operation transformation with various edge cases\n4. Measure performance with high frequency of edits"
          },
          {
            "id": 6,
            "title": "Implement Collaboration Permissions and Session Management",
            "description": "Create a system to manage collaboration sessions with appropriate permissions and access controls.",
            "dependencies": [
              "33.1",
              "33.3",
              "33.5"
            ],
            "details": "1. Design collaboration session data model\n2. Implement session creation and joining functionality\n3. Create role-based permissions for collaboration (viewer, editor, admin)\n4. Implement session invitation system\n5. Add session activity feed to show recent changes\n6. Create session management UI for owners\n7. Implement session timeout and cleanup mechanisms\n8. Add real-time chat functionality within collaboration sessions",
            "status": "pending",
            "testStrategy": "1. Test session creation and joining\n2. Verify permissions are enforced correctly\n3. Test invitation system with various scenarios\n4. Ensure chat messages are delivered in real-time\n5. Validate session cleanup works correctly"
          }
        ]
      },
      {
        "id": 34,
        "title": "Implement Sync Status UI",
        "description": "Create UI components to display synchronization status and progress to users.",
        "details": "1. Design sync status indicator\n2. Implement sync progress display\n3. Create sync error notifications\n4. Add detailed sync status page\n5. Implement manual sync trigger\n6. Create sync history log\n7. Add per-entity sync status\n8. Implement sync settings UI",
        "testStrategy": "1. Test sync status updates during synchronization\n2. Verify error notifications for sync issues\n3. Test manual sync trigger functionality\n4. Ensure sync history correctly logs events\n5. Validate user experience of sync status UI",
        "priority": "medium",
        "dependencies": [
          31
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 35,
        "title": "Implement Multiple Price Tiers",
        "description": "Enhance the subscription system to support multiple pricing tiers with different feature sets.",
        "details": "1. Design pricing tier data model\n2. Implement tier-based feature flags\n3. Create pricing page with tier comparison\n4. Add tier upgrade/downgrade functionality\n5. Implement prorated billing for tier changes\n6. Create tier-specific usage limits\n7. Add tier selection during signup\n8. Implement tier-based analytics",
        "testStrategy": "1. Test tier-based feature access\n2. Verify upgrade/downgrade functionality\n3. Test prorated billing calculations\n4. Ensure usage limits are enforced by tier\n5. Validate tier selection during signup",
        "priority": "medium",
        "dependencies": [
          7,
          8,
          9,
          10
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 36,
        "title": "Implement Free Trial Logic",
        "description": "Add support for free trials of premium features with automatic conversion to paid plans.",
        "details": "1. Design trial data model\n2. Implement trial activation process\n3. Create trial expiration handling\n4. Add trial status indicators\n5. Implement trial-to-paid conversion\n6. Create trial extension functionality\n7. Add trial usage analytics\n8. Implement trial notification emails",
        "testStrategy": "1. Test trial activation and expiration\n2. Verify trial status is correctly displayed\n3. Test conversion from trial to paid subscription\n4. Ensure trial extensions work correctly\n5. Validate trial notification emails",
        "priority": "medium",
        "dependencies": [
          7,
          8,
          9,
          10
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 37,
        "title": "Implement Workflow Templates",
        "description": "Create a system for predefined workflow templates that users can instantiate and customize.",
        "details": "1. Design workflow template data model\n2. Implement template creation interface\n3. Create template instantiation process\n4. Add template parameter customization\n5. Implement template versioning\n6. Create template library UI\n7. Add template import/export functionality\n8. Implement template analytics",
        "testStrategy": "1. Test template creation and editing\n2. Verify template instantiation with parameters\n3. Test template versioning\n4. Ensure template library displays correctly\n5. Validate import/export functionality",
        "priority": "medium",
        "dependencies": [
          11,
          12,
          13,
          14
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 38,
        "title": "Implement Error Recovery for Workflows",
        "description": "Create robust error recovery mechanisms for workflows to handle failures gracefully.",
        "details": "1. Implement step-level error handling\n2. Create workflow-level error policies\n3. Add retry mechanisms with backoff\n4. Implement checkpoint-based recovery\n5. Create manual intervention UI for errors\n6. Add error notification system\n7. Implement partial results saving\n8. Create error analytics and reporting",
        "testStrategy": "1. Test error handling at step and workflow levels\n2. Verify retry mechanisms work correctly\n3. Test checkpoint-based recovery after failures\n4. Ensure manual intervention UI works properly\n5. Validate error notifications and reporting",
        "priority": "medium",
        "dependencies": [
          11,
          12,
          13,
          14
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 39,
        "title": "Implement Analytics Integration",
        "description": "Add analytics tracking throughout the application to monitor usage and performance.",
        "details": "1. Set up analytics provider integration\n2. Implement page view tracking\n3. Add event tracking for key user actions\n4. Create custom dimensions for user properties\n5. Implement conversion tracking\n6. Add performance metric tracking\n7. Create analytics dashboard\n8. Implement privacy controls for analytics",
        "testStrategy": "1. Verify page view tracking works correctly\n2. Test event tracking for various user actions\n3. Ensure custom dimensions are properly set\n4. Validate conversion tracking accuracy\n5. Test privacy controls for analytics opt-out",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 40,
        "title": "Implement SEO Optimization",
        "description": "Enhance the application with SEO best practices for better discoverability.",
        "details": "1. Implement dynamic meta tags\n2. Create sitemap generation\n3. Add structured data markup\n4. Implement canonical URLs\n5. Create robots.txt configuration\n6. Add OpenGraph and Twitter card metadata\n7. Implement server-side rendering for key pages\n8. Create SEO performance monitoring",
        "testStrategy": "1. Test meta tag generation for various pages\n2. Verify sitemap includes all public pages\n3. Test structured data with validation tools\n4. Ensure canonical URLs are correctly set\n5. Validate OpenGraph and Twitter card previews",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 41,
        "title": "Create Example Todos Table with Real-time Features",
        "description": "Implement a todos table as a demonstration of the real-time synchronization capabilities using Electric SQL, tRPC subscriptions, and local-first architecture.",
        "details": "Create a fully-featured todos application that showcases:\n1. Database schema for todos with user ownership and organization support\n2. Electric SQL shape configuration for real-time sync\n3. tRPC subscription endpoints for todo updates\n4. Local-first CRUD operations with optimistic updates\n5. Real-time collaboration features (live cursors, presence)\n6. Offline support with sync queue\n7. Conflict resolution for concurrent edits\n8. UI components showing sync status and real-time updates",
        "testStrategy": "1. Test todo creation, update, and deletion in online/offline modes\n2. Verify real-time sync between multiple clients\n3. Test conflict resolution with concurrent edits\n4. Validate offline queue processing\n5. Test presence and collaboration features\n6. Measure sync latency and performance",
        "status": "done",
        "dependencies": [
          28,
          31,
          32,
          33
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and implement database schema for todos",
            "description": "Create the database schema for todos with user ownership and organization support using Drizzle ORM.",
            "dependencies": [],
            "details": "Define the todos table schema with the following fields: id (primary key), title, description, completed (boolean), user_id (foreign key), organization_id (foreign key), created_at, updated_at, due_date, priority (enum: low, medium, high), and tags (text array). Also create necessary indexes for efficient querying and relationships to users and organizations tables. Use Drizzle ORM for schema definition and migrations.",
            "status": "done",
            "testStrategy": "Verify schema creation with test inserts and queries. Ensure foreign key constraints work properly. Test schema migrations for future changes."
          },
          {
            "id": 2,
            "title": "Configure Electric SQL shapes for todos",
            "description": "Set up Electric SQL shape configuration to enable real-time synchronization of todo items.",
            "dependencies": [
              "41.1"
            ],
            "details": "Define Electric SQL shapes for todos that specify which fields should be synchronized in real-time. Create shapes for individual todos, user-specific todos, and organization-wide todos. Configure sync rules based on user permissions and organization membership. Implement proper namespacing to avoid conflicts. Set up appropriate sync intervals and conflict resolution strategies in the Electric configuration.",
            "status": "done",
            "testStrategy": "Test shape definitions with sample data. Verify correct synchronization patterns based on user context. Ensure proper permissions are enforced in sync operations."
          },
          {
            "id": 3,
            "title": "Implement tRPC router with subscription endpoints",
            "description": "Create a tRPC router with CRUD operations and subscription endpoints for todo updates.",
            "dependencies": [
              "41.1",
              "41.2"
            ],
            "details": "Implement a tRPC router with procedures for creating, reading, updating, and deleting todos. Add subscription endpoints that emit events when todos are created, updated, or deleted. Implement proper authentication and authorization checks in the router. Create helper functions for filtering todos based on user permissions and organization membership. Ensure subscription endpoints handle connection management properly.",
            "status": "done",
            "testStrategy": "Test CRUD operations with various permission scenarios. Verify subscription events are emitted correctly. Test authentication and authorization logic. Measure performance under load."
          },
          {
            "id": 4,
            "title": "Develop React components for todo management",
            "description": "Create React components for displaying and interacting with todos, including list views, detail views, and forms.",
            "dependencies": [
              "41.3"
            ],
            "details": "Build a TodoList component for displaying todos with filtering and sorting options. Create a TodoItem component for individual todo display with inline editing capabilities. Implement TodoForm for creating and editing todos. Add TodoFilters component for filtering by status, priority, and tags. Create TodoStats component for displaying summary information. Use React hooks for state management and implement proper loading and error states.",
            "status": "done",
            "testStrategy": "Write unit tests for individual components. Test component rendering with various data states. Verify user interactions work as expected. Test accessibility compliance."
          },
          {
            "id": 5,
            "title": "Implement local-first CRUD operations with optimistic updates",
            "description": "Create hooks and utilities for local-first CRUD operations with optimistic UI updates.",
            "dependencies": [
              "41.3",
              "41.4"
            ],
            "details": "Develop custom hooks (useTodoCreate, useTodoUpdate, useTodoDelete) that perform operations locally first, then synchronize with the server. Implement optimistic updates to immediately reflect changes in the UI. Create a local storage cache for offline operation. Implement retry logic for failed operations. Add proper error handling and rollback mechanisms for failed optimistic updates. Create utilities for managing the local state and synchronization queue.",
            "status": "done",
            "testStrategy": "Test CRUD operations in both online and offline scenarios. Verify optimistic updates work correctly. Test error handling and rollback mechanisms. Measure performance of local operations."
          },
          {
            "id": 6,
            "title": "Add real-time collaboration features",
            "description": "Implement real-time collaboration features such as live cursors, presence indicators, and concurrent editing.",
            "dependencies": [
              "41.5"
            ],
            "details": "Create a presence system that shows which users are currently viewing or editing a todo. Implement live cursors to show where other users are focusing. Add real-time indicators for who is editing which todo. Create a conflict resolution UI for handling concurrent edits. Implement a locking mechanism to prevent conflicting edits. Add visual indicators for sync status (synced, syncing, offline). Use WebSockets or a similar technology for real-time communication.",
            "status": "done",
            "testStrategy": "Test presence indicators with multiple simulated users. Verify live cursors update in real-time. Test conflict resolution with forced concurrent edits. Ensure proper handling of users going offline and coming back online."
          },
          {
            "id": 7,
            "title": "Implement offline support with sync queue",
            "description": "Create a robust offline support system with a synchronization queue for pending changes.",
            "dependencies": [
              "41.5"
            ],
            "details": "Implement a sync queue that stores changes made while offline. Create a background synchronization process that applies queued changes when connectivity is restored. Add conflict detection and resolution for changes made offline. Implement a priority system for the sync queue to handle critical updates first. Create a UI for viewing the sync queue status. Add persistence for the sync queue to survive page reloads. Implement proper error handling for failed synchronizations.",
            "status": "done",
            "testStrategy": "Test offline operation by simulating network disconnection. Verify changes are queued properly. Test synchronization when connectivity is restored. Verify conflict resolution works correctly. Test persistence across page reloads."
          },
          {
            "id": 8,
            "title": "Create UI components for sync status and real-time updates",
            "description": "Develop UI components that display synchronization status and real-time update information.",
            "dependencies": [
              "41.6",
              "41.7"
            ],
            "details": "Create a SyncStatus component that shows the current synchronization state (online, offline, syncing). Implement a SyncQueue component that displays pending changes. Add toast notifications for successful/failed sync operations. Create a CollaborationPanel showing active users and their activities. Implement visual indicators for items being edited by others. Add animations for newly updated items. Create a debug panel for developers to inspect sync operations. Ensure all components are accessible and provide clear visual feedback.",
            "status": "done",
            "testStrategy": "Test UI components with various sync states. Verify visual indicators accurately reflect the system state. Test accessibility of all components. Conduct usability testing to ensure the UI effectively communicates sync status to users."
          }
        ]
      },
      {
        "id": 42,
        "title": "Implement tRPC Procedures for Todo CRUD Operations",
        "description": "Create type-safe tRPC procedures for managing todos, including create, read, update, and delete operations that integrate with the existing Drizzle schema and Supabase setup.",
        "details": "Implementation details for tRPC todo procedures:\n\n1. **Setup tRPC Router for Todos**:\n   - Create a dedicated router file (`src/server/api/routers/todo.ts`)\n   - Import necessary tRPC utilities and Drizzle schema\n\n2. **Define Zod Validation Schemas**:\n   - Create input validation schemas for each procedure:\n     ```typescript\n     const createTodoSchema = z.object({\n       title: z.string().min(1).max(255),\n       description: z.string().optional(),\n       dueDate: z.date().optional(),\n       completed: z.boolean().default(false),\n       organizationId: z.string().uuid()\n     });\n     \n     const updateTodoSchema = z.object({\n       id: z.string().uuid(),\n       title: z.string().min(1).max(255).optional(),\n       description: z.string().optional(),\n       dueDate: z.date().optional(),\n       completed: z.boolean().optional()\n     });\n     \n     const deleteTodoSchema = z.object({\n       id: z.string().uuid()\n     });\n     ```\n\n3. **Implement CRUD Procedures**:\n   - **Create Todo**:\n     ```typescript\n     create: protectedProcedure\n       .input(createTodoSchema)\n       .mutation(async ({ ctx, input }) => {\n         // Verify user belongs to organization\n         // Insert todo using Drizzle\n         // Return created todo\n       }),\n     ```\n   \n   - **Read Todos**:\n     ```typescript\n     getAll: protectedProcedure\n       .input(z.object({\n         organizationId: z.string().uuid(),\n         limit: z.number().min(1).max(100).default(50),\n         cursor: z.string().nullish()\n       }))\n       .query(async ({ ctx, input }) => {\n         // Verify user belongs to organization\n         // Query todos with pagination\n         // Return todos with next cursor\n       }),\n     \n     getById: protectedProcedure\n       .input(z.object({ id: z.string().uuid() }))\n       .query(async ({ ctx, input }) => {\n         // Verify user has access to todo\n         // Query single todo\n         // Return todo or throw not found\n       }),\n     ```\n   \n   - **Update Todo**:\n     ```typescript\n     update: protectedProcedure\n       .input(updateTodoSchema)\n       .mutation(async ({ ctx, input }) => {\n         // Verify user has access to todo\n         // Update todo using Drizzle\n         // Return updated todo\n       }),\n     ```\n   \n   - **Delete Todo**:\n     ```typescript\n     delete: protectedProcedure\n       .input(deleteTodoSchema)\n       .mutation(async ({ ctx, input }) => {\n         // Verify user has access to todo\n         // Delete todo using Drizzle\n         // Return success message\n       }),\n     ```\n\n4. **Implement Filtering and Sorting**:\n   - Add procedures for filtered queries:\n     ```typescript\n     getFiltered: protectedProcedure\n       .input(z.object({\n         organizationId: z.string().uuid(),\n         completed: z.boolean().optional(),\n         search: z.string().optional(),\n         sortBy: z.enum(['createdAt', 'dueDate', 'title']).default('createdAt'),\n         sortDirection: z.enum(['asc', 'desc']).default('desc')\n       }))\n       .query(async ({ ctx, input }) => {\n         // Implement filtering and sorting logic\n       }),\n     ```\n\n5. **Add Batch Operations**:\n   - Implement batch update/delete for efficiency:\n     ```typescript\n     batchUpdate: protectedProcedure\n       .input(z.object({\n         ids: z.array(z.string().uuid()),\n         completed: z.boolean()\n       }))\n       .mutation(async ({ ctx, input }) => {\n         // Verify user has access to all todos\n         // Batch update todos\n       }),\n     ```\n\n6. **Error Handling**:\n   - Implement proper error handling with descriptive messages\n   - Use tRPC's error formatter for consistent error responses\n   - Handle database errors and validation failures gracefully\n\n7. **Integration with Electric SQL**:\n   - Ensure procedures work with the Electric SQL setup for real-time sync\n   - Implement proper shape queries for todos\n\n8. **Register Router**:\n   - Add the todo router to the main tRPC router in `src/server/api/root.ts`",
        "testStrategy": "1. **Unit Testing**:\n   - Write unit tests for each tRPC procedure using Vitest\n   - Mock database interactions to test procedure logic in isolation\n   - Test validation error cases with invalid inputs\n   - Verify authorization checks work correctly\n\n2. **Integration Testing**:\n   - Test procedures against a test database\n   - Verify CRUD operations modify the database correctly\n   - Test pagination and filtering functionality\n   - Ensure proper error responses for invalid operations\n\n3. **Authorization Testing**:\n   - Test that users can only access todos in their organizations\n   - Verify users cannot modify todos they don't have access to\n   - Test organization admin privileges for managing all todos\n\n4. **Performance Testing**:\n   - Test batch operations with large datasets\n   - Verify query performance with indexes\n   - Test pagination with large result sets\n\n5. **End-to-End Testing**:\n   - Create Playwright tests that use the tRPC procedures from the frontend\n   - Test complete user flows for todo management\n   - Verify real-time updates work correctly with Electric SQL\n\n6. **Manual Testing**:\n   - Test procedures using tRPC client in the browser\n   - Verify type safety works correctly in the frontend\n   - Test error handling and user feedback\n\n7. **API Documentation Testing**:\n   - Generate and verify API documentation for the todo procedures\n   - Ensure all procedures are properly documented with examples",
        "status": "pending",
        "dependencies": [
          41,
          33,
          15
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Setup tRPC Router and Zod Validation Schemas",
            "description": "Create the todo router file and define Zod validation schemas for all CRUD operations",
            "dependencies": [],
            "details": "Create the router file at src/server/api/routers/todo.ts. Import necessary tRPC utilities and Drizzle schema. Define comprehensive Zod validation schemas for create, update, delete, and query operations with proper validation rules for each field. Include schemas for filtering, sorting, and pagination.\n<info added on 2025-08-05T04:31:42.755Z>\nSuccessfully completed the setup of tRPC router and Zod validation schemas for todos. Created comprehensive validation schemas including createTodoSchema, updateTodoSchema, todoIdSchema, todosByOrganizationSchema, and todosByStatusSchema. All schemas include proper validation rules with helpful error messages. Also exported the schema enums (todoPriority, todoStatus) from the CRUD package and registered the todo router in the main tRPC router. Build passes successfully with no TypeScript errors.\n</info added on 2025-08-05T04:31:42.755Z>",
            "status": "done",
            "testStrategy": "Write unit tests to verify schema validation works correctly for valid and invalid inputs. Test edge cases like minimum/maximum string lengths and required fields."
          },
          {
            "id": 2,
            "title": "Implement Create and Read Procedures",
            "description": "Create tRPC procedures for adding new todos and retrieving todos with various query options",
            "dependencies": [
              "42.1"
            ],
            "details": "Implement the 'create' mutation that validates input, verifies user belongs to the organization, and inserts the todo using Drizzle. Implement 'getAll' query with pagination support, 'getById' for single todo retrieval, and 'getFiltered' for advanced filtering and sorting. Ensure proper error handling and authorization checks in each procedure.",
            "status": "pending",
            "testStrategy": "Test each procedure with valid inputs and verify correct database operations. Test authorization by attempting operations with users who don't have access. Verify pagination works correctly with various limit and cursor values."
          },
          {
            "id": 3,
            "title": "Implement Update and Delete Procedures",
            "description": "Create tRPC procedures for modifying and removing existing todos",
            "dependencies": [
              "42.1"
            ],
            "details": "Implement the 'update' mutation that allows partial updates to todos, verifying user access before modification. Implement the 'delete' mutation that removes todos after authorization checks. Add proper error handling for cases like todo not found or unauthorized access. Return appropriate success responses and updated data.",
            "status": "pending",
            "testStrategy": "Test update with various field combinations. Verify deleted todos are no longer accessible. Test error cases like attempting to update/delete non-existent todos or todos the user doesn't have access to."
          },
          {
            "id": 4,
            "title": "Implement Batch Operations",
            "description": "Create procedures for efficient batch updates and deletions of multiple todos",
            "dependencies": [
              "42.3"
            ],
            "details": "Implement 'batchUpdate' mutation that can modify multiple todos at once (e.g., marking several todos as completed). Implement 'batchDelete' for removing multiple todos in one operation. Ensure proper transaction handling for atomicity. Verify user has access to all todos in the batch before proceeding with operations.",
            "status": "pending",
            "testStrategy": "Test batch operations with various numbers of items. Verify transactions roll back properly if any item fails. Test partial authorization scenarios where user has access to some but not all todos in the batch."
          },
          {
            "id": 5,
            "title": "Register Router and Integrate with Project",
            "description": "Add the todo router to the main tRPC router and ensure compatibility with Electric SQL for real-time sync",
            "dependencies": [
              "42.2",
              "42.3",
              "42.4"
            ],
            "details": "Register the todo router in src/server/api/root.ts. Ensure procedures work with Electric SQL for real-time synchronization by implementing proper shape queries. Add comprehensive error handling with descriptive messages using tRPC's error formatter. Test the complete integration to verify all procedures work end-to-end with the existing Drizzle schema and Supabase setup.",
            "status": "pending",
            "testStrategy": "Perform integration testing to verify the router works correctly within the full application. Test real-time sync capabilities with Electric SQL. Verify error messages are properly formatted and helpful for debugging."
          }
        ]
      },
      {
        "id": 43,
        "title": "Set up Rocicorp Zero as Real-time Sync Engine",
        "description": "Replace Electric SQL with Rocicorp Zero for local-first, real-time synchronization. Configure Zero server and client, integrate with Supabase auth, and establish initial sync configuration.",
        "details": "1. Install Rocicorp Zero packages:\n   - Add @rocicorp/zero and @rocicorp/zero-nextjs to dependencies\n   - Install @rocicorp/reflect for server-side sync\n   - Add @rocicorp/replicache for client-side persistence\n\n2. Configure Zero Server:\n   - Create zero-server configuration in packages/zero/server\n   - Set up Reflect server with WebSocket support\n   - Configure server-side authentication middleware\n   - Implement server-side data access patterns\n   - Set up server-side change subscriptions\n\n3. Set up Zero Client:\n   - Create Zero client configuration in packages/zero/client\n   - Configure Replicache for local persistence\n   - Set up client-side mutators for data operations\n   - Implement optimistic UI update patterns\n   - Configure sync intervals and retry logic\n\n4. Integrate with Supabase Authentication:\n   - Create auth adapter for Zero to use Supabase sessions\n   - Implement JWT validation for WebSocket connections\n   - Set up user ID mapping between Supabase and Zero\n   - Configure permission checks using Supabase RLS\n   - Implement session refresh handling\n\n5. Create Initial Sync Configuration:\n   - Define initial data schema for Zero\n   - Set up entity definitions and relationships\n   - Configure sync rules and filters\n   - Implement initial data loading strategy\n   - Create migration plan from existing data\n\n6. Implement Connection Management:\n   - Create connection status monitoring\n   - Implement reconnection logic with exponential backoff\n   - Add connection state to React context\n   - Create hooks for sync status\n   - Implement offline queue management\n\n7. Configure Development Environment:\n   - Set up local Zero server for development\n   - Create Docker configuration for Zero server\n   - Configure environment variables\n   - Set up development proxy for WebSockets\n   - Create development data seeding scripts\n\n8. Create Zero Provider Component:\n   - Implement ZeroProvider React component\n   - Configure provider with auth context\n   - Set up error boundaries for sync failures\n   - Create development tools integration\n   - Implement sync debugging utilities",
        "testStrategy": "1. Test Zero server initialization and configuration\n2. Verify client-server WebSocket connection establishment\n3. Test authentication flow with Supabase sessions\n4. Validate data synchronization between multiple clients\n5. Test offline functionality and data persistence\n6. Verify optimistic updates and rollback on conflicts\n7. Test reconnection logic under various network conditions\n8. Validate permission enforcement through Supabase RLS\n9. Test data migration from existing database\n10. Verify performance with concurrent users and large datasets",
        "status": "pending",
        "dependencies": [
          31,
          32,
          33
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Install Rocicorp Zero packages",
            "description": "Install @rocicorp/zero, @rocicorp/zero-nextjs, @rocicorp/reflect, and @rocicorp/replicache packages",
            "details": "Run pnpm add @rocicorp/zero @rocicorp/zero-nextjs @rocicorp/reflect @rocicorp/replicache. Create basic package structure under packages/zero with client and server subdirectories.",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 43
          },
          {
            "id": 2,
            "title": "Configure Zero Server",
            "description": "Set up Reflect server with WebSocket support and authentication middleware",
            "details": "Create zero-server configuration in packages/zero/server. Set up Reflect server with WebSocket support. Configure server-side authentication middleware using Supabase JWT validation. Implement server-side data access patterns.",
            "status": "pending",
            "dependencies": [
              "43.1"
            ],
            "parentTaskId": 43
          },
          {
            "id": 3,
            "title": "Set up Zero Client",
            "description": "Configure Replicache client for local persistence and optimistic updates",
            "details": "Create Zero client configuration in packages/zero/client. Configure Replicache for local persistence. Set up client-side mutators for data operations. Implement optimistic UI update patterns. Configure sync intervals and retry logic.",
            "status": "pending",
            "dependencies": [
              "43.1"
            ],
            "parentTaskId": 43
          },
          {
            "id": 4,
            "title": "Integrate with Supabase Authentication",
            "description": "Create auth adapter for Zero to use Supabase sessions and JWT validation",
            "details": "Create auth adapter for Zero to use Supabase sessions. Implement JWT validation for WebSocket connections. Set up user ID mapping between Supabase and Zero. Configure permission checks using Supabase RLS.",
            "status": "pending",
            "dependencies": [
              "43.2",
              "43.3"
            ],
            "parentTaskId": 43
          },
          {
            "id": 5,
            "title": "Create Initial Sync Configuration",
            "description": "Define data schema and sync rules for Zero",
            "details": "Define initial data schema for Zero. Set up entity definitions and relationships. Configure sync rules and filters. Implement initial data loading strategy. Create migration plan from existing data.",
            "status": "pending",
            "dependencies": [
              "43.4"
            ],
            "parentTaskId": 43
          },
          {
            "id": 6,
            "title": "Create Zero Provider Component",
            "description": "Implement React provider for Zero client with auth and sync status",
            "details": "Implement ZeroProvider React component. Configure provider with auth context. Set up error boundaries for sync failures. Create hooks for sync status. Implement sync debugging utilities.",
            "status": "pending",
            "dependencies": [
              "43.5"
            ],
            "parentTaskId": 43
          }
        ]
      },
      {
        "id": 44,
        "title": "Remove Electric SQL and PGlite References",
        "description": "Clean up Electric SQL and PGlite dependencies and code references from the web application while preserving package structure for future use.",
        "details": "1. **Remove Electric SQL Dependencies**:\n   - Remove @electric-sql/client, @electric-sql/pglite, and related packages from package.json\n   - Clean up pnpm-lock.yaml by running pnpm install after dependency removal\n   - Remove electric-proxy app entirely from apps/ directory\n\n2. **Clean Up Code References**:\n   - Remove Electric provider components and context\n   - Remove PGlite worker setup and configuration files\n   - Remove Electric SQL specific imports and type definitions\n   - Clean up database connection and sync configuration related to Electric\n   - Remove Electric-specific environment variables and configuration\n\n3. **Update Application Code**:\n   - Replace Electric SQL data access patterns with direct tRPC calls\n   - Remove Electric SQL hooks and reactive queries\n   - Update components that used Electric SQL subscriptions\n   - Remove Electric SQL schema definitions and migrations\n   - Clean up Electric SQL specific middleware and utilities\n\n4. **Preserve Package Structure**:\n   - Keep packages/zero directory structure intact for future Rocicorp Zero implementation\n   - Maintain database schema compatibility for future sync engine integration\n   - Document removed functionality for potential future reference\n   - Keep configuration placeholders for real-time sync features\n\n5. **Update Documentation and Configuration**:\n   - Update README and documentation to remove Electric SQL references\n   - Clean up configuration files and environment variable documentation\n   - Update deployment scripts and Docker configurations if applicable",
        "testStrategy": "1. Verify application builds successfully without Electric SQL dependencies\n2. Test that all pages and components render without Electric SQL errors\n3. Confirm tRPC queries work correctly as replacement for Electric subscriptions\n4. Test todo functionality works with direct database access via tRPC\n5. Verify no Electric SQL imports remain in the codebase\n6. Ensure packages/zero directory structure is preserved\n7. Test development and build commands work without errors\n8. Validate that removed functionality doesn't break existing features",
        "status": "pending",
        "dependencies": [
          41,
          42,
          43
        ],
        "priority": "high",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-05T02:58:50.419Z",
      "updated": "2025-08-09T02:09:29.096Z",
      "description": "Tasks for master context"
    }
  },
  "feature-zero-todos": {
    "tasks": [
      {
        "id": 1,
        "title": "Zero runtime config: Add NEXT_PUBLIC_ZERO_URL and auth token strategy",
        "description": "Implement zero runtime configuration by adding NEXT_PUBLIC_ZERO_URL environment variable and establishing auth token strategy for seamless deployment across environments.",
        "details": "1. Add NEXT_PUBLIC_ZERO_URL environment variable to support zero runtime configuration\n2. Create auth token strategy that works with the zero URL configuration\n3. Update .env.example file with:\n   - NEXT_PUBLIC_ZERO_URL example value\n   - Auth token related environment variables\n   - Clear comments explaining each variable's purpose\n4. Update README.md with setup instructions:\n   - How to configure NEXT_PUBLIC_ZERO_URL for different environments\n   - Auth token setup process\n   - Environment variable configuration steps\n   - Any prerequisites or dependencies\n5. Ensure the configuration works seamlessly without requiring runtime modifications\n6. Consider different deployment scenarios (development, staging, production)\n7. Implement proper fallback mechanisms if environment variables are not set",
        "testStrategy": "1. Test configuration in development environment with .env.local\n2. Verify NEXT_PUBLIC_ZERO_URL is properly accessible in client-side code\n3. Test auth token strategy works correctly with the zero URL configuration\n4. Validate that missing environment variables are handled gracefully\n5. Test deployment scenarios by temporarily removing/modifying environment variables\n6. Verify README instructions by following them step-by-step in a clean environment\n7. Confirm .env.example contains all necessary variables with proper examples\n8. Test that the application builds and runs successfully with the new configuration",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Create apps/web/.env.example with Supabase and Zero variables",
            "description": "Add a sample env file for the Next.js app including Supabase and Zero settings with clear comments.",
            "details": "Include:\n- NEXT_PUBLIC_SUPABASE_URL\n- NEXT_PUBLIC_SUPABASE_ANON_KEY\n- SUPABASE_SERVICE_ROLE_KEY (server-only)\n- NEXT_PUBLIC_ZERO_URL (e.g., http://localhost:4243)\n- NEXT_PUBLIC_USE_ZERO (default false)\n- Optional Axiom/Sentry vars\nAdd instructional comments for each.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 1
          },
          {
            "id": 2,
            "title": "Export and provider fixes in @superscale/zero",
            "description": "Fix package exports and provider typing; ensure auth token strategy uses Supabase session access_token.",
            "details": "- Export Z and ZeroProviderProps from packages/zero/src/provider.tsx\n- Update packages/zero/src/index.ts to export { Z, ZeroProviderProps, schema }\n- Ensure provider uses session.access_token for auth and depends on server in useMemo\n- Add guards to avoid runtime errors when props missing\n<info added on 2025-08-09T07:22:42.081Z>\nImplementation completed successfully:\n- Exported Z and ZeroProviderProps from provider.tsx and updated index.ts exports\n- Added comprehensive guards for missing server or session.access_token that gracefully no-op\n- Optimized useMemo dependencies to [user.id, server, session.access_token] for proper re-computation\n- Cleaned up unused React import to resolve ESLint warning\n- Modified files: packages/zero/src/provider.tsx, packages/zero/src/index.ts\n</info added on 2025-08-09T07:22:42.081Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 1
          },
          {
            "id": 3,
            "title": "Add ZeroWrapper in org layout using env and Supabase session",
            "description": "Gate Zero usage behind feature flag and env var, passing session token to provider.",
            "details": "- Create client component zero-wrapper.tsx under apps/web/src/app/[organization]/components\n- Read clientConfig.NEXT_PUBLIC_ZERO_URL and NEXT_PUBLIC_USE_ZERO\n- Wrap children with <Z user={user} session={session} server={url}> when enabled; otherwise pass-through\n- Update [organization]/layout.tsx to fetch session and use wrapper\n<info added on 2025-08-09T07:24:06.428Z>\nIMPLEMENTATION COMPLETE:\n\nSuccessfully implemented ZeroWrapper component at apps/web/src/app/[organization]/components/zero-wrapper.tsx with feature flag support reading clientConfig.NEXT_PUBLIC_ZERO_URL and NEXT_PUBLIC_USE_ZERO. When enabled and session exists, wraps children with Z provider component passing user, session, and server props. When disabled or missing environment variables, provides pass-through behavior.\n\nUpdated apps/web/src/app/[organization]/layout.tsx to fetch user and session data via getCurrentSession and integrate ZeroWrapper. Removed non-null assertions to handle Session | null gracefully.\n\nComponent automatically falls back to pass-through rendering when Zero is disabled or environment variables are missing, ensuring backward compatibility.\n</info added on 2025-08-09T07:24:06.428Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 1
          },
          {
            "id": 4,
            "title": "Update README to document Zero env and auth token strategy",
            "description": "Document how to configure NEXT_PUBLIC_ZERO_URL and how the session access token is used for Zero auth.",
            "details": "- Update Zero local dev section: env example, feature flag, token strategy note\n- Replace 'wired later' with actual wiring via ZeroWrapper\n- Mention Supabase local symmetric JWT secret context\n- Include fallback behavior if vars are missing\n<info added on 2025-08-09T07:24:19.065Z>\nSuccessfully updated README documentation with Zero environment configuration and auth token strategy details, including Supabase session integration and local JWT validation context. README now includes comprehensive setup instructions and explanatory content for Zero implementation. The .env.example file creation remains pending due to editor limitations and will be addressed in a separate update.\n</info added on 2025-08-09T07:24:19.065Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 1
          }
        ]
      },
      {
        "id": 3,
        "title": "Zero schema and permissions: Generate packages/zero/src/schema.gen.ts from Drizzle; add packages/zero/src/schema.ts with read permissions for todos by organization_id and current user membership",
        "description": "Implement permission-based data access controls and mutators for todos based on organization membership and user authentication, building on existing schema generation.",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "details": "1. Create packages/zero/src/schema.ts:\n   - Import generated types from existing schema.gen.ts\n   - Implement read permissions system for todos table\n   - Add organization_id-based access control logic\n   - Implement current user membership validation\n   - Create permission functions that check:\n     * User belongs to the organization that owns the todo\n     * User has appropriate role/permissions within that organization\n     * Handle edge cases for public/private todos if applicable\n\n2. Implement mutators in packages/zero/src/mutators.ts:\n   - Create createTodo function with proper authorization checks\n   - Implement updateTodo with version control and permissions\n   - Add deleteTodo with organization membership validation\n   - Ensure all mutators respect organization-based access controls\n   - Handle concurrent updates and data consistency\n\n3. Permission implementation details:\n   - Define getUserOrganizations() helper function\n   - Create canReadTodo(userId, todoId) permission check\n   - Implement organizationMembershipCheck() utility\n   - Add proper error handling for unauthorized access attempts\n   - Ensure permissions are enforced at the data layer level\n\n4. Integration with existing infrastructure:\n   - Wire up with existing Supabase auth system\n   - Leverage established organization structure\n   - Ensure schema.ts works seamlessly with the Zero client from Task 2\n   - Make permissions configurable through the zero URL and auth strategy from Task 1\n   - Add TypeScript interfaces for permission contexts and user roles",
        "testStrategy": "1. Test permission functions with various user/organization combinations:\n   - User with valid organization membership can read todos\n   - User without membership cannot access organization todos\n   - Invalid user IDs are handled gracefully\n2. Test mutator functions with proper authorization:\n   - createTodo respects organization membership\n   - updateTodo validates user permissions and handles concurrent updates\n   - deleteTodo prevents unauthorized deletions\n3. Integration test with Supabase auth to verify authentication flow\n4. Test permission enforcement at different access levels\n5. Test error handling for malformed organization IDs and user contexts\n6. Performance test permission checks with large datasets to ensure scalability\n7. Test integration with Zero client configuration and auth token strategy from Task 1\n8. Verify CRUD operations maintain data consistency and proper audit trails",
        "subtasks": [
          {
            "id": 1,
            "title": "Generate schema.gen.ts from existing Drizzle schema",
            "description": "Create the schema.gen.ts file by generating TypeScript types from the existing Drizzle schema definitions, focusing on the todos table and related entities",
            "dependencies": [],
            "details": "1. Locate the existing Drizzle schema definitions in the codebase (likely in packages/db/src/schema.ts or similar)\n2. Set up the Zero schema generation process to create packages/zero/src/schema.gen.ts\n3. Generate TypeScript types for todos table including all fields (id, title, description, organization_id, created_at, updated_at, etc.)\n4. Include related entity types needed for permissions (users, organizations, organization_members)\n5. Ensure generated types are compatible with Zero's type system and include all necessary metadata",
            "status": "done",
            "testStrategy": "1. Verify schema.gen.ts is generated successfully without errors\n2. Check that all todo table fields are properly typed\n3. Validate that related entity types (users, organizations) are included\n4. Test that generated types can be imported and used in TypeScript without compilation errors"
          },
          {
            "id": 2,
            "title": "Create schema.ts with Zero permission definitions",
            "description": "Implement the schema.ts file that imports generated types and defines the Zero schema with permission rules for todos based on organization membership",
            "dependencies": [
              "3.1"
            ],
            "details": "1. Create packages/zero/src/schema.ts file\n2. Import generated types from schema.gen.ts\n3. Define the Zero schema using Zero's schema definition API\n4. Configure the todos table with proper field definitions\n5. Set up relationships between todos, organizations, and users\n6. Define basic schema structure that will be extended with permissions in the next subtask\n<info added on 2025-08-09T07:57:37.688Z>\nCompleted implementation using SQL-based permission expressions following the ztunes pattern from https://github.com/rocicorp/ztunes/blob/676a8fbe208369c7c2ed0620b763ca82933f414e/zero/schema.ts. Implemented comprehensive organization-based permissions for all tables (todos, organizationMembers, organizations, tags, users) using EXISTS clauses with organizationMembers table for membership validation. Applied authUserID checks and role-based permissions for admin, owner, and member roles. Successfully exported schema from index.ts with no lint errors.\n</info added on 2025-08-09T07:57:37.688Z>\n<info added on 2025-08-09T08:03:25.912Z>\nFinal Zero schema implementation completed. The schema.ts file now uses the official Zero permissions API with:\n\n- Proper `definePermissions` function with `AuthData` type matching Supabase JWT structure (`sub` field)\n- Organization-based permission functions using `exists` and `whereExists` APIs correctly\n- Comprehensive permissions for all tables (todos, organizationMembers, organizations, tags, users)\n- Proper relationship-based access control for todos via organization membership\n- `ANYONE_CAN` permissions for todoTags junction table\n- Full TypeScript compliance with all lint errors resolved\n- Exported types ready for Zero client integration: Todo, User, Organization, OrganizationMember, Tag, AuthData, Schema\n\nThe implementation follows Zero's official documentation patterns and is ready for production use.\n</info added on 2025-08-09T08:03:25.912Z>\n<info added on 2025-08-09T08:11:28.075Z>\nSecurity vulnerability fix applied for todoTags junction table permissions. Previously used insecure ANYONE_CAN permissions allowing unauthorized access to tag associations across organizations. Implemented allowIfTodoTagOrganizationMember function with proper organization membership validation through todo->organization->members relationship chain. Updated all operations (select, insert, delete) to enforce organization-based access control, ensuring multi-tenant data isolation and preventing cross-organization tag manipulation. Verified permission function properly filters by deletedAt and maintains consistent security model across all schema tables.\n</info added on 2025-08-09T08:11:28.075Z>",
            "status": "done",
            "testStrategy": "1. Verify schema.ts imports work correctly from schema.gen.ts\n2. Test that Zero schema is properly defined and can be instantiated\n3. Validate table and field definitions match the generated types\n4. Check that the schema exports correctly for use in other modules"
          },
          {
            "id": 3,
            "title": "Implement read permissions for todos based on organization membership",
            "description": "Add permission functions to schema.ts that enforce organization-based access control for reading todos, checking user membership and roles",
            "dependencies": [
              "3.2"
            ],
            "details": "1. Implement canReadTodo permission function that checks:\n   - User is authenticated\n   - Todo belongs to an organization\n   - User is a member of that organization\n2. Create getUserOrganizations helper to fetch user's organization memberships\n3. Add organizationMembershipCheck utility function\n4. Define permission rules in Zero schema for the todos table\n5. Handle edge cases like system admins or public todos if applicable\n6. Integrate with existing Supabase auth to get current user context\n<info added on 2025-08-09T08:10:34.762Z>\nFixed critical security vulnerability in todoTags junction table permissions.\n\n**Security Issue Identified:**\n- Previous implementation used `ANYONE_CAN` for todoTags, allowing anyone to read, create, or delete todo-tag relationships across all organizations\n- This was a major data leak and privilege escalation vulnerability\n\n**Security Fix Implemented:**\n- Created `allowIfTodoTagOrganizationMember` permission function\n- Now verifies user is a member of the organization that owns the todo before allowing any todoTag operations\n- Applied to all todoTag operations: select, insert, delete\n- Uses proper relationship traversal: todoTags -> todo -> organization -> members\n\n**Current Security Model:**\n- Users can only see todo-tag relationships for todos in their organizations\n- Users can only create todo-tag relationships for todos they can access\n- Users can only delete todo-tag relationships for todos they can access\n- All operations properly enforce organization-based access control\n\nThis fix ensures data isolation between organizations and prevents unauthorized access to todo-tag relationships.\n</info added on 2025-08-09T08:10:34.762Z>",
            "status": "done",
            "testStrategy": "1. Test canReadTodo with valid organization member - should allow access\n2. Test with non-member user - should deny access\n3. Test with unauthenticated user - should deny access\n4. Test edge cases like deleted organizations or suspended users\n5. Verify permission functions integrate correctly with Zero's permission system"
          },
          {
            "id": 4,
            "title": "Create organization membership validation utilities",
            "description": "Implement helper functions for validating user organization membership and roles, integrating with the existing Supabase auth system",
            "dependencies": [
              "3.3"
            ],
            "details": "1. Create packages/zero/src/permissions/organizationHelpers.ts\n2. Implement getUserOrganizationRole(userId, organizationId) function\n3. Create isOrganizationMember(userId, organizationId) checker\n4. Add getUserPermissionsContext() to gather user's full permission context\n5. Implement caching strategy for organization membership lookups\n6. Handle error cases and provide meaningful error messages\n7. Ensure utilities work with existing organization_members table structure",
            "status": "done",
            "testStrategy": "1. Unit test getUserOrganizationRole with various membership states\n2. Test isOrganizationMember with active, inactive, and non-existent memberships\n3. Verify caching improves performance for repeated permission checks\n4. Test error handling for database connection issues\n5. Validate integration with Supabase auth tokens"
          },
          {
            "id": 5,
            "title": "Export schema and configure Zero client integration",
            "description": "Export the completed schema with permissions and ensure it integrates properly with the Zero client configuration from Task 2",
            "dependencies": [
              "3.3",
              "3.4"
            ],
            "details": "1. Export the schema from packages/zero/src/schema.ts as default export\n2. Create index.ts in packages/zero/src to re-export schema and related utilities\n3. Ensure schema works with Zero client initialization using NEXT_PUBLIC_ZERO_URL\n4. Add TypeScript types for permission contexts and results\n5. Document the expected auth token format for Zero client\n6. Create example usage showing how to initialize Zero with the schema and permissions\n7. Verify schema is ready for use by the mutators in Task 4",
            "status": "done",
            "testStrategy": "1. Test that schema exports correctly and can be imported in other packages\n2. Verify Zero client can be initialized with the schema\n3. Test that permissions are enforced when querying through Zero client\n4. Validate TypeScript types provide proper intellisense\n5. Ensure integration with auth strategy from Task 1 works correctly"
          }
        ]
      },
      {
        "id": 4,
        "title": "Todo mutators: Implement packages/zero/src/mutators.ts with createTodo, updateTodo, deleteTodo",
        "description": "Implement CRUD operations for todos including creation, versioned updates, and deletion in the Zero package mutators module.",
        "details": "1. Create packages/zero/src/mutators.ts:\n   - Import necessary types from schema.gen.ts and schema.ts\n   - Import zero client types and utilities\n\n2. Implement createTodo function:\n   - Accept todo data (title, description, organization_id, etc.)\n   - Validate user permissions using organization membership\n   - Generate unique ID and timestamps\n   - Insert new todo record into database\n   - Return created todo with generated fields\n   - Handle validation errors and database constraints\n\n3. Implement updateTodo function with optimistic concurrency control:\n   - Accept todo ID, update data, and version number\n   - Validate user has write permissions for the todo\n   - Check version matches current record (prevent lost updates)\n   - Update only provided fields, preserve others\n   - Increment version number atomically\n   - Return updated todo with new version\n   - Handle version conflicts with descriptive errors\n\n4. Implement deleteTodo function:\n   - Accept todo ID and current version\n   - Validate user permissions and ownership\n   - Soft delete or hard delete based on requirements\n   - Handle cascading relationships if any\n   - Return success confirmation\n\n5. Add TypeScript interfaces:\n   - CreateTodoInput, UpdateTodoInput types\n   - TodoMutationResult with success/error states\n   - Version conflict error types\n\n6. Export all mutator functions and types from the module\n<info added on 2025-08-09T08:14:59.782Z>\nSUPERSEDED: This task has been superseded by Task 11 \"Implement comprehensive Zero ZQL mutations for all schema tables\" which provides a more comprehensive approach covering all mutations for todos, organizations, members, tags, and users in a well-organized structure with one module per table. The functionality originally planned for this single mutators.ts file is now better addressed through the modular approach in Task 11, which creates separate mutation modules (todos.ts, organizations.ts, etc.) in the packages/zero/src/mutations/ directory with improved organization and maintainability.\n</info added on 2025-08-09T08:14:59.782Z>",
        "testStrategy": "1. Unit test createTodo function:\n   - Valid todo creation with all required fields\n   - Permission validation for different organization memberships\n   - Input validation and error handling\n   - Database constraint violations\n\n2. Unit test updateTodo function:\n   - Successful update with version increment\n   - Version conflict detection and error handling\n   - Partial updates preserve unchanged fields\n   - Permission validation for todo ownership\n   - Non-existent todo ID handling\n\n3. Unit test deleteTodo function:\n   - Successful deletion with proper permissions\n   - Permission denied scenarios\n   - Non-existent todo handling\n   - Verify cascading effects if applicable\n\n4. Integration tests:\n   - Test mutators work with actual Zero client instance\n   - Verify schema permissions integrate correctly\n   - Test concurrent operations and version conflicts\n   - End-to-end CRUD workflow testing\n\n5. Error handling tests:\n   - Network failures and timeouts\n   - Database connection issues\n   - Malformed input data\n   - Authentication/authorization failures",
        "status": "cancelled",
        "dependencies": [
          3
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Replace Electric live query in Todos with Zero query",
        "description": "Replace the existing Electric useLiveQuery implementation in the Todos component with Zero's query system, implementing proper filtering and sorting while maintaining the current UI mapping.",
        "details": "1. Locate and update the Todos component (likely in apps/web/src/components or similar):\n   - Remove Electric imports (useLiveQuery, Electric client)\n   - Import Zero query hooks and client from packages/zero\n   - Replace useLiveQuery call with Zero's equivalent query method\n\n2. Implement Zero query with proper filtering:\n   - Filter todos by user_id (current authenticated user)\n   - Filter by organization_id (current user's organization context)\n   - Filter by deleted_at IS NULL to exclude soft-deleted records\n   - Order results by updated_at DESC for most recent first\n\n3. Maintain existing UI mapping:\n   - Ensure the query result structure matches what the UI expects\n   - Preserve any existing data transformations or computed properties\n   - Keep loading states, error handling, and empty states intact\n\n4. Update component dependencies:\n   - Ensure ZeroProvider is available in component tree (from Task 5)\n   - Use organization context for organization_id filtering\n   - Integrate with session auth for user_id filtering\n\n5. Test data flow:\n   - Verify todos load correctly with new query system\n   - Confirm filtering works properly (user sees only their org's todos)\n   - Ensure real-time updates still function as expected",
        "testStrategy": "1. Verify todos component renders without errors after Zero query integration\n2. Test filtering functionality:\n   - Confirm only todos belonging to current user's organization are displayed\n   - Verify deleted todos (deleted_at IS NOT NULL) are properly excluded\n   - Test with multiple users in same organization see shared todos\n3. Test sorting and ordering:\n   - Verify todos appear in descending order by updated_at timestamp\n   - Test that newly updated todos move to top of list\n4. Test real-time updates:\n   - Create new todo and verify it appears immediately\n   - Update existing todo and confirm changes reflect in UI\n   - Delete todo and verify it disappears from list\n5. Test UI mapping compatibility:\n   - Ensure all existing todo properties are still accessible\n   - Verify loading states work correctly during query execution\n   - Test error handling when query fails\n6. Cross-browser testing to ensure Zero query works consistently across different environments",
        "status": "done",
        "dependencies": [
          3
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Ensure Zero provider context is mounted and organizationId is available",
            "description": "Verify `Z` provider is mounted at an appropriate level (root/org layout). Pass resolved organizationId from layout to Todos component to avoid client-side lookups. Provider should gracefully no-op if auth/env missing.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 6
          },
          {
            "id": 2,
            "title": "Replace Electric hook with Zero useQuery in Todos",
            "description": "Remove Electric client/hooks and implement Zero useQuery from @rocicorp/zero/react to fetch todos with filters: organizationId match, deletedAt IS NULL; order by updatedAt DESC. Keep result shape compatible with current UI.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 6
          },
          {
            "id": 3,
            "title": "Preserve loading/empty/error states; no-op if provider inactive",
            "description": "Maintain existing UX states during query. If `Z` provider or auth/env are absent (per pass-through provider), render safe placeholder and avoid client lookups.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 6
          },
          {
            "id": 4,
            "title": "Remove Electric artifacts and keep minimal surface changes",
            "description": "Delete Electric-specific imports and clients in Todos components. Avoid deep refactors; keep props/state shapes stable; adapt only query hook and result mapping.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 6
          },
          {
            "id": 5,
            "title": "Manual verification of live updates, filters and ordering",
            "description": "Verify: org-based filtering, deletedAt excluded, updatedAt DESC ordering. Confirm live updates: create/update/delete reflect immediately. Ensure UI mapping compatibility.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 6
          }
        ]
      },
      {
        "id": 7,
        "title": "Replace tRPC mutations with Zero mutators",
        "description": "Replace existing tRPC mutation calls (onAdd/onEdit/onToggle/onDelete) with Zero mutator functions, implementing a short-term feature flag fallback to ensure smooth transition and rollback capability.",
        "details": "1. Locate existing tRPC mutation usage in the Todos component:\n   - Find onAdd, onEdit, onToggle, and onDelete handlers\n   - Identify current tRPC mutation calls and their parameters\n   - Document existing error handling and loading states\n\n2. Implement Zero mutator integration:\n   - Import createTodo, updateTodo, deleteTodo from packages/zero/src/mutators\n   - Replace tRPC onAdd with createTodo mutator call\n   - Replace tRPC onEdit with updateTodo mutator call\n   - Replace tRPC onToggle with updateTodo mutator call (toggle completed status)\n   - Replace tRPC onDelete with deleteTodo mutator call\n   - Maintain existing parameter structure and response handling\n\n3. Implement feature flag fallback system:\n   - Add NEXT_PUBLIC_USE_ZERO_MUTATIONS environment variable\n   - Create conditional logic to switch between tRPC and Zero mutations\n   - Ensure both code paths maintain identical UI behavior\n   - Add error boundary handling for both mutation systems\n\n4. Update error handling and loading states:\n   - Adapt existing loading states to work with Zero mutations\n   - Ensure error messages are consistent between tRPC and Zero\n   - Maintain optimistic updates where applicable\n\n5. Clean up imports and dependencies:\n   - Remove unused tRPC mutation imports when feature flag is disabled\n   - Ensure Zero mutator imports are properly typed",
        "testStrategy": "1. Test Zero mutator integration:\n   - Verify onAdd creates todos with correct data and organization scoping\n   - Test onEdit updates todo fields while maintaining version control\n   - Confirm onToggle properly flips completed status\n   - Validate onDelete marks todos as deleted (soft delete)\n\n2. Test feature flag functionality:\n   - Test with NEXT_PUBLIC_USE_ZERO_MUTATIONS=true (Zero mutations active)\n   - Test with NEXT_PUBLIC_USE_ZERO_MUTATIONS=false (tRPC fallback active)\n   - Verify identical UI behavior in both modes\n   - Test feature flag toggle during runtime\n\n3. Test error handling and edge cases:\n   - Network failures during mutation calls\n   - Permission denied scenarios\n   - Invalid data validation\n   - Concurrent modification conflicts\n\n4. Integration testing:\n   - Test full CRUD workflow with Zero mutations\n   - Verify real-time updates work correctly with Zero queries\n   - Test rollback capability by switching feature flag\n   - Validate performance compared to tRPC mutations",
        "status": "done",
        "dependencies": [
          6,
          "11"
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Preloading and TTLs: Preload the todo query in apps/web/src/app/[organization]/layout.tsx and set TTL per Zero docs",
        "description": "Implement query preloading in the organization layout to optimize initial page load performance and configure appropriate TTL settings according to Zero documentation.",
        "details": "1. Update apps/web/src/app/[organization]/layout.tsx:\n   - Import Zero query preloading utilities from packages/zero\n   - Implement todo query preloading in the layout component\n   - Configure preloading to occur during server-side rendering or component initialization\n   - Ensure preloaded data is scoped to the current organization context\n\n2. Configure TTL (Time To Live) settings per Zero documentation:\n   - Research Zero docs for recommended TTL configurations for todo queries\n   - Set appropriate cache expiration times based on data freshness requirements\n   - Configure TTL for different query types (user todos, organization todos)\n   - Implement cache invalidation strategies for real-time updates\n\n3. Optimize preloading strategy:\n   - Preload only essential todo data needed for initial render\n   - Consider user permissions and organization membership for preloading scope\n   - Implement error handling for failed preload attempts\n   - Ensure preloading doesn't block critical rendering path\n\n4. Integration with existing Zero setup:\n   - Ensure preloading works with ZeroProvider context from Task 5\n   - Coordinate with Zero query implementation from Task 6\n   - Maintain compatibility with auth token strategy from previous tasks\n<info added on 2025-08-11T23:43:32.470Z>\n5. Preload related users for instant names/avatars:\n   - Implement todos query preload with ttl: '5m' configuration\n   - Preload organization members and their user data using z.query.organizationMembers.where('organizationId', orgId).related('user').preload({ttl:'5m'})\n   - Alternative approach: preload only users referenced by current todos for a narrower dataset\n   - Implement safe no-op behavior when Zero is inactive to prevent errors during fallback scenarios\n   - Ensure user data preloading coordinates with todo preloading for optimal performance\n   - Cache user avatar and name data with same TTL as todo data to maintain consistency\n</info added on 2025-08-11T23:43:32.470Z>",
        "testStrategy": "1. Test preloading functionality:\n   - Verify todo query data is preloaded before component render\n   - Confirm preloaded data is scoped correctly to current organization\n   - Test preloading performance impact on initial page load times\n   - Validate preloading works with both SSR and client-side navigation\n\n2. Test TTL configuration:\n   - Verify cache expiration behaves according to configured TTL settings\n   - Test cache invalidation when todos are modified\n   - Confirm stale data is refreshed appropriately\n   - Test TTL behavior across different browser sessions\n\n3. Test error handling:\n   - Verify graceful fallback when preloading fails\n   - Test behavior with network connectivity issues\n   - Confirm error states don't break the layout rendering\n\n4. Performance testing:\n   - Measure initial page load improvements with preloading enabled\n   - Test memory usage with cached preloaded data\n   - Verify preloading doesn't cause unnecessary API calls",
        "status": "done",
        "dependencies": [
          6
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Reinstate FK constraints: todos.userId -> users.id (and related)",
            "description": "Restore DB FK constraints between todos and users removed for Electric/PGlite; ensures referential integrity for preloading related users.",
            "details": "1) Confirm prior FK removal via git history\n2) Drizzle migration: add FK todos.userId -> users.id (ON DELETE RESTRICT unless backfill needed)\n3) Clean up orphans before enabling FKs\n4) Validate Zero path and update tests\n5) Document change\n",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 8
          }
        ]
      },
      {
        "id": 9,
        "title": "Feature flag + cleanup: Add flag to switch Electric/Zero for Todos screen; remove Electric usage in this page after validation",
        "description": "Implement a feature flag system to toggle between Electric and Zero implementations for the Todos screen, with cleanup logic to remove Electric usage after Zero validation is complete.",
        "details": "1. Create feature flag infrastructure:\n   - Add ENABLE_ZERO_TODOS environment variable to control the feature flag\n   - Update .env.example with ENABLE_ZERO_TODOS=false (default to Electric)\n   - Create a feature flag utility function in packages/zero/src/featureFlags.ts to check flag status\n\n2. Implement conditional rendering in Todos component:\n   - Import feature flag utility and both Electric and Zero implementations\n   - Use conditional logic to render either Electric or Zero version based on flag\n   - Ensure both implementations maintain identical UI/UX behavior\n   - Add loading states and error boundaries for both paths\n\n3. Create cleanup mechanism:\n   - Add utility function to detect when Zero validation is complete (e.g., after successful query execution and mutations)\n   - Implement automatic Electric code removal after validation period\n   - Add logging to track feature flag usage and validation status\n   - Create migration guide for removing Electric dependencies\n\n4. Update organization layout:\n   - Conditionally mount Electric or Zero providers based on feature flag\n   - Ensure session auth works correctly with both implementations\n   - Handle provider switching gracefully without breaking existing sessions",
        "testStrategy": "1. Test feature flag functionality:\n   - Verify ENABLE_ZERO_TODOS=false renders Electric implementation\n   - Verify ENABLE_ZERO_TODOS=true renders Zero implementation\n   - Test feature flag changes without app restart\n   - Confirm both implementations show identical todo data\n\n2. Test conditional provider mounting:\n   - Verify Electric provider works when flag is disabled\n   - Verify Zero provider works when flag is enabled\n   - Test session auth persistence across provider switches\n   - Validate no memory leaks occur during provider transitions\n\n3. Test cleanup mechanism:\n   - Verify Electric code removal triggers after successful Zero validation\n   - Test that cleanup doesn't break active Zero functionality\n   - Confirm all Electric imports and dependencies are properly removed\n   - Validate error handling during cleanup process\n\n4. Integration testing:\n   - Test full todo CRUD operations with both implementations enabled\n   - Verify performance metrics are comparable between Electric and Zero\n   - Test edge cases like network failures with both implementations\n   - Confirm rollback capability by switching flag back to Electric",
        "status": "pending",
        "dependencies": [
          6,
          7,
          8
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Tests, lint, docs: Update integration tests for Zero path; run lint; docs for envs and rollout",
        "description": "Comprehensive testing, linting, and documentation updates for the Zero implementation path, including integration test updates, code quality checks, and environment/rollout documentation.",
        "details": "1. Update integration tests for Zero implementation:\n   - Update existing integration tests to work with Zero query system instead of Electric\n   - Create new integration tests for Zero mutators (createTodo, updateTodo, deleteTodo)\n   - Test feature flag switching between Electric and Zero implementations\n   - Update test data setup to work with Zero schema and permissions\n   - Test preloading functionality and TTL configurations\n   - Verify organization-scoped filtering works correctly in tests\n\n2. Run comprehensive linting:\n   - Execute ESLint across all modified files in packages/zero/\n   - Run TypeScript compiler checks on new Zero implementation\n   - Fix any linting errors in todo component updates\n   - Ensure code formatting consistency across Electric to Zero migration\n   - Run Prettier on all modified files\n\n3. Create environment and rollout documentation:\n   - Document NEXT_PUBLIC_ZERO_URL configuration for different environments (dev/staging/prod)\n   - Create rollout guide explaining feature flag usage and Electric to Zero migration\n   - Document ENABLE_ZERO_TODOS feature flag behavior and testing procedures\n   - Add troubleshooting section for common Zero implementation issues\n   - Update deployment documentation with Zero-specific environment requirements\n   - Create developer onboarding guide for Zero vs Electric differences",
        "testStrategy": "1. Integration test verification:\n   - Run updated integration test suite and verify 100% pass rate with Zero implementation\n   - Test feature flag integration tests with both ENABLE_ZERO_TODOS=true and false\n   - Verify organization-scoped data isolation in integration tests\n   - Test preloading integration tests show performance improvements\n\n2. Linting verification:\n   - Ensure zero linting errors across all modified files\n   - Verify TypeScript compilation passes without warnings\n   - Confirm code formatting meets project standards\n\n3. Documentation validation:\n   - Test environment setup instructions with fresh development environment\n   - Validate feature flag rollout procedures work as documented\n   - Verify troubleshooting documentation resolves common issues\n   - Confirm all environment variables are properly documented with examples",
        "status": "pending",
        "dependencies": [
          6,
          7,
          8,
          9
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Implement comprehensive Zero ZQL mutations for all schema tables",
        "description": "Create a complete set of custom ZQL mutation functions in packages/zero/src/mutations/ directory with one module per major table, including proper organization-based permission validation, optimistic concurrency control, and comprehensive TypeScript typing.",
        "details": "1. Create packages/zero/src/mutations/ directory structure:\n   - Create index.ts to re-export all mutation modules\n   - Create separate files: todos.ts, organizations.ts, organizationMembers.ts, tags.ts, todoTags.ts, users.ts\n\n2. Implement todos.ts mutations:\n   - createTodo: Accept title, description, organization_id, user_id; validate organization membership\n   - updateTodo: Include version checking for optimistic concurrency control\n   - deleteTodo: Implement soft delete with deleted_at timestamp\n   - toggleTodoCompletion: Toggle completed status with proper validation\n   - Each mutation should check user's organization membership before allowing operations\n\n3. Implement organizations.ts mutations:\n   - createOrganization: Create org and automatically add creator as admin member\n   - updateOrganization: Only allow admins to update org details\n   - deleteOrganization: Soft delete with cascade handling for related data\n   - Include proper role-based access control\n\n4. Implement organizationMembers.ts mutations:\n   - inviteMember: Generate invitation with unique token and expiry\n   - acceptInvitation: Validate token and create membership\n   - removeMember: Check permissions (admins can remove anyone, users can remove themselves)\n   - updateMemberRole: Only admins can change roles\n   - Handle edge cases like preventing removal of last admin\n\n5. Implement tags.ts mutations:\n   - createTag: Scoped to organization with unique name constraint\n   - updateTag: Update name/color with organization scope validation\n   - deleteTag: Cascade delete tag associations\n   - Include organization-based permissions\n\n6. Implement todoTags.ts mutations:\n   - addTagToTodo: Validate both todo and tag belong to same organization\n   - removeTagFromTodo: Check permissions through todo ownership\n   - bulkAddTags: Efficiently add multiple tags to a todo\n   - bulkRemoveTags: Efficiently remove multiple tags\n\n7. Implement users.ts mutations:\n   - updateProfile: Allow users to update their own profile data\n   - updatePreferences: Handle user preferences/settings\n   - Include self-only permission validation\n\n8. Common patterns across all mutations:\n   - Import Zero client and types from schema.gen.ts\n   - Use Zero's transaction support for multi-step operations\n   - Include comprehensive error handling with specific error codes\n   - Add TypeScript interfaces for all input/output types\n   - Implement audit logging for sensitive operations\n   - Use Zero's built-in validation capabilities\n   - Return consistent response formats with success indicators",
        "testStrategy": "1. Unit test each mutation module:\n   - Test successful operations with valid inputs\n   - Test permission denials for unauthorized users\n   - Test organization scope validation\n   - Test optimistic concurrency control for updates\n   - Test error handling for constraint violations\n\n2. Integration test cross-table mutations:\n   - Test createOrganization creates admin membership\n   - Test deleteOrganization cascades properly\n   - Test tag associations with todos\n   - Test invitation flow end-to-end\n\n3. Test TypeScript typing:\n   - Verify all mutations have proper input/output types\n   - Test type inference works correctly\n   - Validate error types are properly typed\n\n4. Test Zero-specific features:\n   - Verify transactions roll back on errors\n   - Test optimistic UI updates work correctly\n   - Validate mutations integrate with Zero's caching\n\n5. Security testing:\n   - Test SQL injection attempts are blocked\n   - Verify permissions can't be bypassed\n   - Test rate limiting if implemented\n   - Validate input sanitization\n\n6. Performance testing:\n   - Test bulk operations with large datasets\n   - Verify N+1 queries are avoided\n   - Test mutation response times\n\n7. Edge case testing:\n   - Test concurrent updates to same record\n   - Test operations on deleted records\n   - Test maximum field lengths\n   - Test null/undefined handling",
        "status": "pending",
        "dependencies": [
          3
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Todo mutations: createTodo, updateTodo, deleteTodo, toggleTodo",
            "description": "Implement ZQL mutations for todo CRUD operations with organization-based permissions",
            "details": "Create packages/zero/src/mutations/todos.ts with:\n- createTodo: Create new todos with organization membership validation\n- updateTodo: Update todo fields with version control and ownership checks  \n- deleteTodo: Soft/hard delete with permission validation\n- toggleTodo: Toggle completion status with optimistic updates\n- Proper TypeScript types and error handling",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 11
          },
          {
            "id": 2,
            "title": "Organization mutations: createOrganization, updateOrganization, deleteOrganization",
            "description": "Implement ZQL mutations for organization management with proper ownership and admin role validation",
            "details": "Create packages/zero/src/mutations/organizations.ts with:\n- createOrganization: Create new organization and make creator the owner\n- updateOrganization: Update org details (name, settings) with admin/owner permissions\n- deleteOrganization: Soft delete organization with proper cascade handling\n- Handle organization member cleanup and data migration\n- Proper TypeScript types and role-based access control",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 11
          },
          {
            "id": 3,
            "title": "OrganizationMember mutations: inviteMember, acceptInvitation, removeMember, updateMemberRole",
            "description": "Implement ZQL mutations for organization membership management with role-based permissions",
            "details": "Create packages/zero/src/mutations/organizationMembers.ts with:\n- inviteMember: Send invitations with admin/owner permissions, create pending membership\n- acceptInvitation: Accept pending invitations and activate membership\n- removeMember: Remove members with proper permission checks (admin/owner, self-removal)\n- updateMemberRole: Change member roles (owner, admin, member) with permission validation\n- Handle invitation flow integration with existing email system\n- Proper TypeScript types and comprehensive role validation",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 11
          },
          {
            "id": 4,
            "title": "Tag mutations: createTag, updateTag, deleteTag",
            "description": "Implement ZQL mutations for tag management with organization-scoped permissions",
            "details": "Create packages/zero/src/mutations/tags.ts with:\n- createTag: Create new tags within organization with membership validation\n- updateTag: Update tag properties (name, color, description) with permission checks\n- deleteTag: Delete tags and handle associated todoTags cleanup\n- Ensure tags are organization-scoped and validate member permissions\n- Handle tag uniqueness constraints within organizations\n- Proper TypeScript types and validation",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 11
          },
          {
            "id": 5,
            "title": "TodoTag mutations: addTagToTodo, removeTagFromTodo",
            "description": "Implement ZQL mutations for todo-tag associations with secure organization-based permissions",
            "details": "Create packages/zero/src/mutations/todoTags.ts with:\n- addTagToTodo: Associate tags with todos, validating user access to both entities\n- removeTagFromTodo: Remove tag associations with proper permission checks\n- Validate both todo and tag belong to organizations user has access to\n- Handle duplicate associations gracefully\n- Integrate with the secure permissions we implemented in schema.ts\n- Proper TypeScript types and comprehensive validation",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 11
          },
          {
            "id": 6,
            "title": "User mutations: updateUserProfile",
            "description": "Implement ZQL mutations for user profile management with self-access validation",
            "details": "Create packages/zero/src/mutations/users.ts with:\n- updateUserProfile: Update user profile data (name, email, avatar, preferences)\n- Validate users can only update their own profile data\n- Handle email change verification if needed\n- Integrate with Supabase auth system for email updates\n- Proper TypeScript types and validation\n- Handle avatar upload/management if applicable",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 11
          },
          {
            "id": 7,
            "title": "Mutations index and integration",
            "description": "Create main mutations export and integration with Zero client",
            "details": "Create packages/zero/src/mutations/index.ts with:\n- Export all mutation functions from individual modules\n- Create unified mutation client/registry for easy consumption\n- Add comprehensive TypeScript types for all mutations\n- Document usage patterns and error handling\n- Update packages/zero/src/index.ts to export mutations\n- Add integration examples and JSDoc documentation",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 11
          },
          {
            "id": 8,
            "title": "Read permissions: implement Zero definePermissions for query-time auth",
            "description": "Implement organization-based read (select) permissions using Zero's permission system so queries are enforced, following the ztunes example (see https://github.com/rocicorp/ztunes/blob/676a8fbe208369c7c2ed0620b763ca82933f414e/zero/schema.ts?plain=1#L28). Update packages/zero/src/schema.ts to apply select permissions for todos, organizations, tags, users, and todoTags consistent with org membership. Keep writes enforced by custom mutators; permissions here are for reads only.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 11
          },
          {
            "id": 9,
            "title": "Shared Zod validators in @superscale/crud",
            "description": "Create reusable Zod schemas in packages/crud (e.g., src/validators/) for core entities (todo, tag, organization, organizationMember, userProfile). Replace ad-hoc validations in zero mutators (e.g., validateTodoTitle/description) by importing these validators. Export types from the Zod schemas for use across apps (tRPC, mutators, UI forms). Add zod as a dependency to @superscale/crud and re-export validators via @superscale/crud.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 11
          },
          {
            "id": 10,
            "title": "Org tags: query + preload in provider",
            "description": "Load all tags for the current organization to support tag selection and reconciliation when editing todos. Preload with TTL to avoid cold fetches.",
            "details": "- Query: z.query.tags.where('organizationId', orgId).preload({ ttl: '5m' }) in Zero provider init (or layout)\n- Expose tags via a small hook/context for the Todos form\n- Ensure safe no-op when Zero disabled",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 11
          },
          {
            "id": 11,
            "title": "Tag mutator: create org tag",
            "description": "Server mutator to create a tag scoped to an organization with membership validation and unique name per org.",
            "details": "- Add tags.create in server mutators (already in place)\n- Validate org membership and trim/name length\n- Handle org-unique constraint gracefully",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 11
          },
          {
            "id": 12,
            "title": "Save todo tags by id on edit/create",
            "description": "When saving a todo, resolve tag names -> ids (find or create per org), then upsert todoTags for the todo (add missing links, remove stale).",
            "details": "- On create: resolve input.tags names to tag ids (find-or-create), then insert todoTags\n- On update: diff existing todoTags vs requested; insert missing, delete removed\n- Do logic in server mutator using ZQL with membership checks",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 11
          },
          {
            "id": 13,
            "title": "Tag picker in todo form: searchable multi-select",
            "description": "Add searchable tag picker to `todo-form.tsx` using Popover+Command (shadcn) to select existing org tags or create new names. Selected tags show as chips; enter/comma adds current input.",
            "details": "- Hook: useOrgTags(orgId) with Zero useQuery; optionally preload in provider\n- UI: Command inside Popover; debounce filter; keyboard navigation\n- Behavior: choosing suggestion adds to values.tags; if none, show Create 'query' option to append raw name\n- Validation: trim, dedupe, max length\n- Integrate with nameid resolve before save",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 11
          }
        ]
      },
      {
        "id": 12,
        "title": "Implement shared authentication utilities for Zero custom mutators",
        "description": "Create comprehensive authentication utilities in packages/zero/src/auth.ts following the Rocicorp zbugs pattern, providing functions to validate user permissions, organization membership, and role-based access control for use in both client and server mutators.",
        "details": "1. Create packages/zero/src/auth.ts with authentication utilities:\n   - Import necessary types from schema.gen.ts and Supabase JWT types\n   - Define AuthContext interface containing user info, JWT claims, and organization data\n   - Implement JWT parsing and validation utilities for Supabase tokens\n\n2. Implement core authentication functions:\n   - hasOrgAccess(userId: string, orgId: string): Promise<boolean> - Check if user has any access to organization\n   - isOrgMember(userId: string, orgId: string): Promise<boolean> - Verify active organization membership\n   - isOrgAdmin(userId: string, orgId: string): Promise<boolean> - Check admin role in organization\n   - getUserOrganizations(userId: string): Promise<Organization[]> - Get all organizations for a user\n   - validateOrgPermission(userId: string, orgId: string, permission: string): Promise<boolean> - Generic permission validator\n\n3. Implement JWT and session utilities:\n   - parseSupabaseJWT(token: string): AuthContext - Extract user and org info from JWT\n   - validateSession(token: string): Promise<boolean> - Verify JWT signature and expiration\n   - getSessionUserId(token: string): string | null - Extract user ID from JWT claims\n   - getSessionOrgId(token: string): string | null - Extract current org context from JWT\n\n4. Create helper functions for mutator integration:\n   - createAuthContext(token: string): Promise<AuthContext> - Build complete auth context\n   - requireOrgAccess(authContext: AuthContext, orgId: string): void - Throw if no access\n   - requireOrgAdmin(authContext: AuthContext, orgId: string): void - Throw if not admin\n   - withAuth<T>(token: string, fn: (auth: AuthContext) => Promise<T>): Promise<T> - Auth wrapper\n\n5. Add TypeScript types and interfaces:\n   - Define Permission enum for different permission levels\n   - Create OrgRole type union ('member' | 'admin' | 'owner')\n   - Define error types for authentication failures\n   - Export all types for use in mutators\n\n6. Implement caching layer for performance:\n   - Cache organization membership lookups with TTL\n   - Cache parsed JWT claims to avoid repeated parsing\n   - Implement cache invalidation on membership changes",
        "testStrategy": "1. Unit test JWT parsing and validation:\n   - Test parseSupabaseJWT with valid Supabase JWT tokens\n   - Test handling of expired tokens and invalid signatures\n   - Verify correct extraction of user ID and organization claims\n   - Test edge cases with missing or malformed claims\n\n2. Test organization membership functions:\n   - Mock database queries for organization_members table\n   - Test hasOrgAccess returns true for valid memberships\n   - Test isOrgMember filters out inactive memberships\n   - Test isOrgAdmin correctly identifies admin roles\n   - Test getUserOrganizations returns all user's organizations\n\n3. Test permission validation:\n   - Test validateOrgPermission with various permission combinations\n   - Verify permission inheritance (admin has member permissions)\n   - Test rejection of invalid permissions or organizations\n   - Test handling of null/undefined inputs\n\n4. Integration test with mutators:\n   - Create sample mutator using requireOrgAccess\n   - Test mutator rejects unauthorized access attempts\n   - Verify auth context is properly passed to mutators\n   - Test withAuth wrapper handles async operations correctly\n\n5. Test caching behavior:\n   - Verify membership lookups are cached appropriately\n   - Test cache expiration after TTL\n   - Ensure cache invalidation works on membership updates\n   - Test performance improvement with cached lookups\n\n6. Error handling tests:\n   - Test appropriate error messages for auth failures\n   - Verify error types can be caught and handled\n   - Test graceful handling of database connection errors\n   - Ensure no sensitive information leaks in error messages",
        "status": "done",
        "dependencies": [
          3,
          11
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Refactor mutators to implement server mutators extending client mutators following Rocicorp zbugs pattern",
        "description": "Create server-side mutators that extend existing client mutators using the Rocicorp zbugs pattern, implementing authoritative operations with Drizzle adapter while client mutators handle optimistic updates.",
        "details": "1. Create packages/zero/src/server-mutators.ts following Rocicorp zbugs pattern:\n   - Import existing client mutators from mutators.ts or mutations/*.ts\n   - Import Drizzle adapter and database connection utilities\n   - Import shared auth utilities from auth.ts for permission validation\n   - Define ServerMutatorContext extending client context with server-specific properties\n\n2. Implement server mutator wrapper pattern:\n   - Create wrapServerMutator higher-order function that:\n     * Accepts a client mutator function as input\n     * Returns a server mutator with enhanced authorization and validation\n     * Injects server-side context (DB connection, auth state, etc.)\n     * Handles transaction management for atomic operations\n\n3. Extend each client mutator with server-side logic:\n   - createTodo: Add server-side ID generation, timestamp management, and atomic DB writes\n   - updateTodo: Implement server-side version checking and conflict resolution\n   - deleteTodo: Add cascading delete logic for related records (tags, etc.)\n   - Use Drizzle adapter for all database operations\n\n4. Implement permission validation using shared auth utilities:\n   - Call hasOrgAccess/isOrgMember from auth.ts before executing mutations\n   - Validate user permissions at the server level (since Zero's built-in permissions don't apply)\n   - Return appropriate error responses for unauthorized operations\n   - Log security events for audit trail\n\n5. Handle optimistic update reconciliation:\n   - Server mutators return authoritative state after operations\n   - Include version/timestamp data for client reconciliation\n   - Implement conflict resolution strategies for concurrent updates\n   - Return structured error objects that clients can handle gracefully\n\n6. Add server-specific enhancements:\n   - Implement database transaction support for multi-step operations\n   - Add server-side data validation beyond client validation\n   - Include audit logging for all mutation operations\n   - Implement rate limiting and abuse prevention\n\n7. Export server mutators with proper TypeScript typing:\n   - Create ServerMutators type extending ClientMutators\n   - Export individual server mutator functions\n   - Export a combined serverMutators object for easy integration",
        "testStrategy": "1. Unit test server mutator wrapper:\n   - Test wrapServerMutator correctly extends client mutators\n   - Verify server context is properly injected\n   - Test transaction rollback on errors\n   - Verify auth utilities are called before mutations\n\n2. Test individual server mutators:\n   - Test createTodo with valid and invalid organization permissions\n   - Test updateTodo conflict resolution with concurrent updates\n   - Test deleteTodo cascading behavior\n   - Verify Drizzle adapter is used for all DB operations\n\n3. Test permission validation:\n   - Verify unauthorized users cannot execute mutations\n   - Test organization-scoped access control\n   - Ensure auth.ts utilities are properly integrated\n   - Test error responses for permission failures\n\n4. Test optimistic update reconciliation:\n   - Simulate client-server state divergence\n   - Test version conflict resolution\n   - Verify authoritative server state is returned\n   - Test error object structure for client handling\n\n5. Integration tests:\n   - Test full client-to-server mutation flow\n   - Verify optimistic updates are reconciled correctly\n   - Test transaction atomicity across multiple operations\n   - Validate audit logging functionality\n\n6. Performance tests:\n   - Measure mutation latency with Drizzle operations\n   - Test transaction overhead\n   - Verify rate limiting doesn't impact normal usage\n   - Test concurrent mutation handling",
        "status": "done",
        "dependencies": [
          11,
          12
        ],
        "priority": "high",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-09T03:10:38.325Z",
      "updated": "2025-08-12T07:50:46.428Z",
      "description": "Zero-based todos migration and integration tasks"
    }
  }
}